<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stop Fighting Wraparound: Embed Your Rings!</title>

    <!-- Code syntax highlighting with Highlight.js -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">

    <!-- Leaflet CSS for GIS demo -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="">

    <!-- D3 UMD (exposes window.d3) -->
    <script src="https://d3js.org/d3.v7.min.js" defer></script>

    <!-- D3FC UMD bundle (exposes window.fc, includes label-layout) -->
    <script src="https://unpkg.com/d3fc@15" defer></script>

    <style>
:root {
  /* Updated with Ceres logo color palette */
  --bg: #0a1a1f;
  --card: #10161d;
  --ink: #dbe2eb;
  --muted: #9fb0c6;
  --accent: #22d3ee; /* Cyan from logo */
  --accent2: #4ade80; /* Green from logo */
  --accent3: #ff7b7b;
  --warning: #ffb86c;
  --ceres-dark: #0a1a1f;
  --ceres-green: #4ade80;
  --ceres-cyan: #22d3ee;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html,
body {
  height: 100%;
  margin: 0;
  background: radial-gradient(
    1000px 800px at 70% 10%,
    #0e1420 0%,
    var(--bg) 60%
  );
  color: var(--ink);
  font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto,
    Inter, "Helvetica Neue", Arial, sans-serif;
  line-height: 1.35;
}

.slideshow-container {
  position: relative;
  width: 100%;
  height: 100vh;
  display: grid;
  grid-template-rows: 1fr auto;
}

#slide-content {
  padding: 56px 64px;
  background: radial-gradient(
      600px 400px at 10% 5%,
      rgba(112, 181, 255, 0.06),
      transparent 50%
    ),
    radial-gradient(
      700px 500px at 90% 0%,
      rgba(155, 255, 176, 0.05),
      transparent 60%
    );
  border-radius: 12px;
  margin: 20px;
  height: calc(100vh - 80px);
  overflow-y: auto;
  animation: fadeIn 0.5s cubic-bezier(0.2, 0.8, 0.2, 1);
  border: 1px solid rgba(255, 255, 255, 0.08);
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

h1 {
  font-size: 54px;
  font-weight: 750;
  letter-spacing: -0.02em;
  line-height: 1.1;
  color: var(--ink);
  margin-bottom: 30px;
  text-align: center;
}

h2 {
  font-size: 36px;
  font-weight: 700;
  letter-spacing: -0.01em;
  line-height: 1.1;
  color: var(--ink);
  margin: 30px 0 20px 0;
  border-left: 4px solid var(--accent);
  padding-left: 20px;
}

h3 {
  font-size: 22px;
  font-weight: 650;
  color: var(--muted);
  margin: 20px 0 15px 0;
}

h4 {
  font-size: 18px;
  font-weight: 600;
  color: var(--ink);
  margin: 15px 0 10px 0;
}

p,
li {
  font-size: 20px;
  color: #c9d6e5;
  line-height: 1.5;
}

.subtitle {
  text-align: center;
  color: var(--muted);
  font-size: 22px;
  margin-bottom: 40px;
}

.two-column {
  display: grid;
  grid-template-columns: 1.1fr 1fr;
  gap: 26px;
  align-items: start;
  margin: 30px 0;
}

.two-column-equal {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 26px;
  align-items: start;
  margin: 30px 0;
}

.two-column-equal img {
  width: 100%;
  height: auto;
  object-fit: contain;
}

.three-column {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 26px;
  margin: 30px 0;
}

.card,
.highlight-box,
.success-box,
.warning-box,
.info-box {
  background: linear-gradient(
    180deg,
    rgba(255, 255, 255, 0.04),
    rgba(255, 255, 255, 0.02)
  );
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 16px;
  padding: 18px 20px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
  margin: 20px 0;
}

.highlight-box {
  border-left: 4px solid var(--accent3);
  background: linear-gradient(
    180deg,
    rgba(255, 123, 123, 0.08),
    rgba(255, 123, 123, 0.04)
  );
}

.success-box {
  border-left: 4px solid var(--accent2);
  background: linear-gradient(
    180deg,
    rgba(155, 255, 176, 0.08),
    rgba(155, 255, 176, 0.04)
  );
}

.warning-box {
  border-left: 4px solid var(--warning);
  background: linear-gradient(
    180deg,
    rgba(255, 184, 108, 0.08),
    rgba(255, 184, 108, 0.04)
  );
}

.info-box {
  border-left: 4px solid var(--accent);
  background: linear-gradient(
    180deg,
    rgba(112, 181, 255, 0.08),
    rgba(112, 181, 255, 0.04)
  );
}

ul,
ol {
  margin: 15px 0;
  padding-left: 30px;
}

ul.compact li {
  margin-bottom: 8px;
}

li {
  margin: 8px 0;
}

.metric {
  background: rgba(255, 255, 255, 0.04);
  border: 1px solid rgba(255, 255, 255, 0.07);
  padding: 16px;
  border-radius: 14px;
  margin: 10px 0;
  text-align: center;
}

.metric-value {
  font-size: 36px;
  font-weight: 800;
  color: var(--accent);
}

.metric-label {
  color: var(--muted);
  font-size: 14px;
  margin-top: 4px;
  letter-spacing: 0.06em;
  text-transform: uppercase;
}

.code-block {
  background: rgba(0, 0, 0, 0.4);
  color: var(--ink);
  padding: 20px;
  border-radius: 12px;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
    "Liberation Mono", monospace;
  font-size: 16px;
  margin: 15px 0;
  overflow-x: auto;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.navigation {
  position: fixed;
  bottom: 30px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 1000;
  display: flex;
  gap: 8px;
}

.nav-button {
  background: rgba(255, 255, 255, 0.06);
  color: var(--ink);
  border: 1px solid rgba(255, 255, 255, 0.12);
  border-radius: 10px;
  padding: 8px 12px;
  cursor: pointer;
  font-weight: 600;
  font-size: 1em;
  transition: all 0.3s;
}

.nav-button:hover {
  background: rgba(255, 255, 255, 0.12);
  transform: translateY(-2px);
}

.nav-button:disabled {
  background: rgba(255, 255, 255, 0.03);
  color: var(--muted);
  cursor: not-allowed;
  transform: none;
}

.nav-button:focus {
  outline: 2px solid var(--accent);
  outline-offset: 2px;
}

.slide-counter {
  position: fixed;
  bottom: 30px;
  right: 30px;
  background: rgba(0, 0, 0, 0.5);
  color: var(--ink);
  padding: 10px 15px;
  border-radius: 20px;
  font-size: 14px;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.status-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 20px;
  margin: 20px 0;
}

.status-item {
  background: linear-gradient(
    180deg,
    rgba(255, 255, 255, 0.04),
    rgba(255, 255, 255, 0.02)
  );
  border: 2px solid rgba(255, 255, 255, 0.08);
  border-radius: 16px;
  padding: 20px;
  text-align: center;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
}

.status-item.completed {
  border-color: var(--accent2);
  background: linear-gradient(
    180deg,
    rgba(155, 255, 176, 0.08),
    rgba(155, 255, 176, 0.04)
  );
}

.status-item.in-progress {
  border-color: var(--warning);
  background: linear-gradient(
    180deg,
    rgba(255, 184, 108, 0.08),
    rgba(255, 184, 108, 0.04)
  );
}

.status-item.critical {
  border-color: var(--accent3);
  background: linear-gradient(
    180deg,
    rgba(255, 123, 123, 0.08),
    rgba(255, 123, 123, 0.04)
  );
}

.timeline {
  position: relative;
  margin: 30px 0;
}

.timeline-item {
  margin: 20px 0;
  padding-left: 40px;
  position: relative;
}

.timeline-item::before {
  content: "";
  position: absolute;
  left: 15px;
  top: 8px;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: var(--accent);
}

.timeline-item::after {
  content: "";
  position: absolute;
  left: 20px;
  top: 20px;
  width: 2px;
  height: calc(100% + 10px);
  background: rgba(255, 255, 255, 0.1);
}

.timeline-item:last-child::after {
  display: none;
}

.process-flow {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin: 30px 0;
  flex-wrap: wrap;
}

.process-step {
  background: rgba(255, 255, 255, 0.04);
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 16px;
  padding: 20px;
  margin: 10px;
  text-align: center;
  flex: 1;
  min-width: 200px;
  position: relative;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
}

.process-step::after {
  content: "→";
  position: absolute;
  right: -25px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 2em;
  color: var(--accent);
}

.process-step:last-child::after {
  display: none;
}

.mask-example {
  display: grid;
  grid-template-columns: 1fr auto 1fr;
  gap: 20px;
  margin: 20px 0;
  align-items: center;
}

.mask-box {
  background: rgba(255, 255, 255, 0.04);
  border: 1px solid rgba(255, 255, 255, 0.08);
  padding: 20px;
  border-radius: 12px;
  text-align: center;
}

.operation {
  font-size: 2em;
  color: var(--accent);
  font-weight: bold;
}

.badge {
  padding: 3px 8px;
  border-radius: 999px;
  font-size: 12px;
  color: #0a1422;
  background: linear-gradient(90deg, var(--accent), var(--accent2));
  font-weight: 700;
  display: inline-block;
}

.mono {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
    "Liberation Mono", monospace;
  font-size: 16px;
}

.kpi {
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 16px;
}

.kpi .stat {
  text-align: center;
  padding: 16px;
  border-radius: 14px;
  background: rgba(255, 255, 255, 0.04);
  border: 1px solid rgba(255, 255, 255, 0.07);
}

.kpi .num {
  font-size: 36px;
  font-weight: 800;
  color: var(--accent);
}

.kpi .label {
  font-size: 14px;
  color: var(--muted);
  margin-top: 4px;
  letter-spacing: 0.06em;
  text-transform: uppercase;
}

/* Operation list styles for slide 4 */
.operation-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin: 15px 0;
}

.op-item {
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.06);
  border-radius: 8px;
  padding: 12px 16px;
  transition: all 0.2s ease;
}

.op-item:hover {
  background: rgba(255, 255, 255, 0.04);
  border-color: rgba(255, 255, 255, 0.12);
}

.op-item strong {
  color: var(--accent);
  font-weight: 650;
}

.op-item small {
  color: var(--muted);
  font-size: 14px;
  margin-top: 4px;
  display: block;
}

.code-example {
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 12px;
  padding: 20px;
  margin: 15px 0;
}

.formula-showcase {
  text-align: center;
  background: rgba(255, 255, 255, 0.02);
  padding: 16px;
  border-radius: 10px;
  margin: 15px 0;
  border: 1px solid rgba(255, 255, 255, 0.06);
}

.formula-showcase code {
  font-size: 18px;
  font-weight: 600;
  color: var(--accent);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
    "Liberation Mono", monospace;
}

/* Scrollbar styling for dark theme */
::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: rgba(255, 255, 255, 0.05);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.2);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.3);
}

/* Title slide specific styles */
.title-slide {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  height: 100vh;
  background: linear-gradient(135deg, var(--ceres-dark) 0%, #1a2f33 100%);
  color: white;
  padding: 2em;
  position: relative;
}

.logo-container {
  margin-bottom: 2em;
  animation: fadeInScale 0.8s ease-out;
}

.title-logo {
  width: 200px;
  height: auto;
  filter: drop-shadow(0 10px 30px rgba(34, 211, 238, 0.3));
}

@keyframes fadeInScale {
  from {
    opacity: 0;
    transform: scale(0.9);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

.main-title {
  font-size: 3.5em;
  margin-bottom: 0.2em;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
  background: linear-gradient(90deg, var(--ceres-green), var(--ceres-cyan));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.visual-element {
  margin: 2em 0;
}

.presenter-info {
  margin-top: 2em;
  text-align: center;
}

.presenter-info p {
  margin: 0.5em 0;
  font-size: 1.2em;
}

.company-branding {
  margin: 1em 0;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.1em;
}

.Ceres-logo {
  font-size: 2.2em;
  font-weight: 700;
  color: #4caf50;
  letter-spacing: 0.05em;
  text-shadow: 0 2px 4px rgba(76, 175, 80, 0.3);
}

.Ceres-ai {
  font-size: 2.2em;
  font-weight: 300;
  color: #70b5ff;
  letter-spacing: 0.05em;
  text-shadow: 0 2px 4px rgba(112, 181, 255, 0.3);
}

.presenter-info .date {
  font-size: 2em;
  font-weight: 300;
  margin-bottom: 1em;
}

/* Common visual demo styles */
.visual-demo {
  display: flex;
  justify-content: center;
  margin: 2em 0;
}

.code-comparison {
  display: flex;
  gap: 1em;
  margin: 1em 0;
}

.clock-visual {
  margin: 2em 0;
  display: flex;
  justify-content: center;
}

/* Interactive demo styles */
.demo-container {
  display: flex;
  gap: 2em;
  align-items: flex-start;
  margin: 2em 0;
}

.demo-section {
  flex: 2;
}

.code-section {
  flex: 1;
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 12px;
  padding: 20px;
}

.angle-inputs {
  display: flex;
  flex-direction: column;
  gap: 15px;
  margin: 20px 0;
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.06);
  border-radius: 12px;
  padding: 20px;
}

.angle-inputs label {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 16px;
  color: var(--ink);
}

.angle-inputs input[type="range"] {
  flex: 1;
  margin: 0 15px;
  appearance: none;
  height: 6px;
  border-radius: 3px;
  background: rgba(255, 255, 255, 0.1);
  outline: none;
}

.angle-inputs input[type="range"]::-webkit-slider-thumb {
  appearance: none;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: var(--accent);
  cursor: pointer;
}

.angle-inputs input[type="range"]::-moz-range-thumb {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: var(--accent);
  cursor: pointer;
  border: none;
}

.angle-inputs span {
  min-width: 50px;
  font-weight: 600;
  color: var(--accent);
}

.demo-visual {
  display: flex;
  justify-content: center;
  margin: 20px 0;
  background: rgba(255, 255, 255, 0.01);
  border: 1px solid rgba(255, 255, 255, 0.06);
  border-radius: 12px;
  padding: 20px;
}

.demo-results {
  display: flex;
  gap: 20px;
  justify-content: center;
  margin: 20px 0;
}

.result {
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 12px;
  padding: 15px 20px;
  text-align: center;
  min-width: 140px;
}

.wrong-result {
  border-left: 4px solid var(--accent3);
}

.correct-result {
  border-left: 4px solid var(--accent2);
}

.result h4 {
  margin: 0 0 10px 0;
  font-size: 16px;
}

.result p {
  margin: 0;
  font-size: 24px;
  font-weight: 700;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
    "Liberation Mono", monospace;
}

.wrong-result p {
  color: var(--accent3);
}

.correct-result p {
  color: var(--accent2);
}

/* Print styles */
@media print {
  body {
    background: white;
    color: #111;
  }

  #slide-content {
    background: white;
    color: #111;
    border: none;
    box-shadow: none;
    page-break-after: always;
  }

  .navigation,
  .slide-counter {
    display: none !important;
  }

  h1,
  h2,
  h3,
  p,
  li {
    color: #111;
  }

  .card,
  .highlight-box,
  .success-box,
  .warning-box,
  .info-box,
  .status-item {
    background: #fff;
    border: 1px solid #e5e7eb;
    box-shadow: none;
    color: #111;
  }
}

/* Visual comparison layout for robot heading diagrams */
.visual-comparison {
  display: flex;
  justify-content: center;
  align-items: flex-start;
  gap: 2em;
  margin: 2em 0;
  flex-wrap: wrap;
}

.visual-comparison .approach {
  flex: 1;
  max-width: 500px;
  text-align: center;
}

.visual-comparison svg {
  margin: 0 auto;
  display: block;
}

.text-center {
  text-align: center;
}


        /* Code block styling */
        pre code {
            border: 1px solid rgba(255,255,255,0.1) !important;
            border-radius: 12px !important;
            padding: 20px !important;
            display: block;
        }

        /* Maintain our colored container backgrounds */
        .bad-code, .code-example {
            background: linear-gradient(180deg, rgba(255,123,123,0.08), rgba(255,123,123,0.04)) !important;
            border-left: 4px solid var(--accent3) !important;
            border-radius: 8px !important;
            padding: 1em !important;
        }

        .good-code, .code-solution {
            background: linear-gradient(180deg, rgba(155,255,176,0.08), rgba(155,255,176,0.04)) !important;
            border-left: 4px solid var(--accent2) !important;
            border-radius: 8px !important;
            padding: 1em !important;
        }

        .implementation-example {
            background: linear-gradient(180deg, rgba(156,39,176,0.08), rgba(156,39,176,0.04)) !important;
            border-left: 4px solid #9C27B0 !important;
            border-radius: 8px !important;
            padding: 1em !important;
        }

        .universal-class {
            background: linear-gradient(180deg, rgba(33,150,243,0.08), rgba(33,150,243,0.04)) !important;
            border-left: 4px solid #2196F3 !important;
            border-radius: 8px !important;
            padding: 1em !important;
        }

        .approach-bad, .approach-good {
            background: rgba(255,255,255,0.04) !important;
            border: 1px solid rgba(255,255,255,0.08) !important;
            border-radius: 8px !important;
            padding: 1em !important;
        }

        /* Crisp "halo" under label text to keep it readable */
        svg text {
            paint-order: stroke;
            stroke: rgba(8,12,16,.75);
            stroke-width: 3;
        }
        /* Optional: keep strokes consistent when scaling */
        svg *[stroke] {
            vector-effect: non-scaling-stroke;
        }
    </style>

    <!-- Math rendering with MathJax -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\(', '\)']],
                displayMath: [['$$', '$$'], ['\[', '\]']]
            },
            options: {
                renderActions: {
                    addMenu: []  // Disable context menu for cleaner presentation
                }
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <div class="slideshow-container">
        <div id="slide-content"></div>
    </div>

    <!-- Navigation -->
    <div class="navigation">
        <button class="nav-button" onclick="previousSlide()">◀ Previous</button>
        <button class="nav-button" onclick="nextSlide()">Next ▶</button>
    </div>

    <!-- Slide Counter -->
    <div class="slide-counter">
        <span id="current-slide">1</span> / <span id="total-slides">17</span>
    </div>

    <!-- Code highlighting JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>

    <!-- Leaflet JavaScript for GIS demo -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <!-- PixiJS for interactive math demos -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js"></script>
    <script>
        document.addEventListener("DOMContentLoaded", () => {
            hljs.highlightAll();

            // Sanity check for D3 and fc libraries
            console.log("✅ D3 loaded?", typeof d3);
            console.log("✅ fc loaded?", typeof fc);

            if (typeof d3 !== 'undefined' && typeof fc !== 'undefined') {
                console.log("✅ D3 version:", d3.version);
                console.log("✅ fc.layoutLabel exists?", typeof fc.layoutLabel);
            } else {
                console.error("❌ D3 or fc libraries failed to load!");
            }
        });

        // Helper function to expand SVG viewBox to prevent text cutoff
        function expandViewBox(svg, pad = 20) {
            console.log("📐 expandViewBox called with padding:", pad);
            const node = svg.node ? svg.node() : svg;
            const box = node.getBBox();
            const oldViewBox = node.getAttribute("viewBox");
            const newViewBox = [
                box.x - pad,
                box.y - pad,
                box.width + 2 * pad,
                box.height + 2 * pad
            ].join(" ");

            console.log("   Old viewBox:", oldViewBox);
            console.log("   New viewBox:", newViewBox);

            if (svg.attr) {
                svg.attr("viewBox", newViewBox);
            } else {
                node.setAttribute("viewBox", newViewBox);
            }
        }

        // Helper function to wait for libraries to load
        function waitForLibraries(callback, maxRetries = 20) {
            let retries = 0;
            const checkInterval = setInterval(() => {
                retries++;
                if (window.d3 && window.fc) {
                    console.log("✅ D3 and fc libraries loaded");
                    clearInterval(checkInterval);
                    callback();
                } else if (retries >= maxRetries) {
                    console.warn("⚠️ Timeout waiting for D3/fc libraries after", retries, "attempts");
                    clearInterval(checkInterval);
                } else {
                    console.log("⏳ Waiting for D3/fc libraries... attempt", retries);
                }
            }, 100);
        }

        // Helper function to fix SVG text layout and prevent overlap
        function fixSVGLayout(svgElement) {
            console.log("🔧 fixSVGLayout called for SVG element");

            if (!window.d3 || !window.fc) {
                console.warn("⚠️ D3 or fc libraries not loaded yet, will retry...");
                waitForLibraries(() => {
                    console.log("🔄 Retrying fixSVGLayout after libraries loaded");
                    fixSVGLayout(svgElement);
                });
                return;
            }

            const svg = d3.select(svgElement);
            console.log("   SVG selected with D3");

            // Expand viewBox to prevent edge clipping
            expandViewBox(svg, 25);

            // Optional: Apply label layout if there are many text elements
            const textElements = svg.selectAll("text");
            console.log('   Found ' + textElements.size() + ' text elements');

            if (textElements.size() > 4) {
                console.log("   Applying d3fc label layout for", textElements.size(), "text elements");
                // For complex layouts with many labels, use d3fc-label-layout
                try {
                    const labels = textElements.nodes();
                    const layout = fc.layoutLabel()
                        .size(d => {
                            const box = d.getBBox();
                            return [box.width, box.height];
                        })
                        .position(d => {
                            const x = parseFloat(d.getAttribute("x") || 0);
                            const y = parseFloat(d.getAttribute("y") || 0);
                            return [x, y];
                        });

                    svg.datum(labels).call(layout);
                    console.log("   ✅ Label layout applied successfully");
                } catch (e) {
                    console.warn("   ❌ Label layout failed:", e);
                }
            } else {
                console.log("   Skipping label layout (not enough text elements)");
            }
        }

        // Helper function to compute safe SVG bounds
        function computeSvgBounds(svgNode) {
            const svg = d3.select(svgNode);
            const vbAttr = svg.attr("viewBox");
            if (vbAttr) {
                const nums = vbAttr.trim().split(/\s+/).map(Number);
                if (nums.length === 4 && nums.every(Number.isFinite)) {
                    const [vx, vy, vw, vh] = nums;
                    if (vw > 0 && vh > 0) return { x: vx, y: vy, width: vw, height: vh };
                }
            }
            // fallback: bbox + padding, and set a sane viewBox
            const b = svgNode.getBBox();
            const bounds = { x: b.x - 16, y: b.y - 16, width: b.width + 32, height: b.height + 32 };
            svg.attr("viewBox", bounds.x + " " + bounds.y + " " + bounds.width + " " + bounds.height);
            return bounds;
        }

        // Move existing <text> elements with d3fc (no new labels are created)
        window.applyLabelLayout = function applyLabelLayout(svgNode, { anneal = false } = {}) {
            if (!window.d3 || !window.fc) {
                console.warn("applyLabelLayout: d3/fc not present");
                return;
            }

            console.log('🏷️ Applying label layout (reuse existing labels)');
            const svg = d3.select(svgNode);
            const textsSel = svg.selectAll("text");
            const textNodes = textsSel.nodes();

            if (textNodes.length < 2) {
                console.log('   Skipping layout (less than 2 text elements)');
                return; // nothing to resolve
            }

            // normalize anchors to reduce surprises
            textsSel
                .attr("dominant-baseline", function () { return this.getAttribute("dominant-baseline") || "middle"; })
                .attr("text-anchor", function () { return this.getAttribute("text-anchor") || "middle"; });

            const bounds = computeSvgBounds(svgNode);
            console.log('   Using bounds:', bounds);

            // pick strategy
            const base = anneal ? fc.layoutAnnealing() : fc.layoutGreedy();
            const strategy = fc.layoutRemoveOverlaps(base.bounds(bounds));

            // NO component: we don't want new nodes rendered
            const noop = () => {};

            // layout that measures & reads current positions off each datum (the SVGTextElement)
            const layout = fc.layoutLabel(strategy)
                .size(function (d) {
                    const bb = d.getBBox();
                    return [bb.width + 8, bb.height + 6];  // padding around label boxes
                })
                .position(function (d) {
                    return [ +d.getAttribute("x") || 0, +d.getAttribute("y") || 0 ];
                })
                .component(noop);

            // bind nodes as data and run layout
            svg.datum(textNodes).call(layout);

            // now bind those datums to the text selection
            textsSel.data(textNodes);

            // write solved positions back; keep old value as fallback
            textsSel
                .attr("x", function (d) { return (d && Number.isFinite(d.x)) ? d.x : +this.getAttribute("x"); })
                .attr("y", function (d) { return (d && Number.isFinite(d.y)) ? d.y : +this.getAttribute("y"); });
            console.log('   ✅ Label layout applied to', textNodes.length, 'existing text elements (no new nodes created)');
        };

        // Move every <text> to the end of its parent so it paints on top
        function bringTextToFront(svgEl) {
            console.log('📤 Bringing text elements to front');
            const texts = svgEl.querySelectorAll('text');
            texts.forEach(t => t.parentNode.appendChild(t)); // append = top of paint order
            console.log('   ✅ Moved', texts.length, 'text elements to front');
        }

        // Ensure SVG has the filter definitions for labels
        function ensureLabelFilters(svgEl) {
            const NS = "http://www.w3.org/2000/svg";
            let defs = svgEl.querySelector("defs");
            if (!defs) {
                defs = document.createElementNS(NS, "defs");
                svgEl.insertBefore(defs, svgEl.firstChild);
            }

            if (!svgEl.querySelector("#label-shadow")) {
                const f = document.createElementNS(NS, "filter");
                f.setAttribute("id", "label-shadow");
                f.innerHTML = '<feDropShadow dx="0" dy=".7" stdDeviation="1.2" flood-color="#000" flood-opacity=".55"/>';
                defs.appendChild(f);
            }
            if (!svgEl.querySelector("#label-glow")) {
                const f = document.createElementNS(NS, "filter");
                f.setAttribute("id", "label-glow");
                f.setAttribute("x", "-20%");
                f.setAttribute("y", "-20%");
                f.setAttribute("width", "140%");
                f.setAttribute("height", "140%");
                f.innerHTML = '<feGaussianBlur in="SourceAlpha" stdDeviation="1.4" result="blur"/><feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>';
                defs.appendChild(f);
            }
        }

        // Apply styling filters to labels
        function styleLabels(svgEl, { use = "shadow" } = {}) {
            console.log('🎨 Applying', use, 'filter to text labels');
            ensureLabelFilters(svgEl);
            const texts = svgEl.querySelectorAll("text");
            texts.forEach(t => {
                t.setAttribute("filter", 'url(#label-' + use + ')');
            });
            console.log('   ✅ Applied', use, 'filter to', texts.length, 'text elements');
        }

        // Reduce the size of filled endpoint circles; leave stroked rings alone
        function shrinkEndpoints(svgEl, targetR = 5) {
            console.log('🔴 Shrinking endpoint bulbs to radius', targetR);
            let shrunkCount = 0;
            svgEl.querySelectorAll('circle').forEach(c => {
                const r0 = +c.getAttribute('r') || 0;
                const fill = (c.getAttribute('fill') || '').trim().toLowerCase();
                const hasFill = fill && fill !== 'none';
                // Heuristic: rings in your slides have fill="none", endpoints are filled
                if (hasFill && r0 > targetR) {
                    c.setAttribute('r', targetR);
                    shrunkCount++;
                }
            });
            console.log('   ✅ Shrunk', shrunkCount, 'filled circles from larger sizes to', targetR);
        }

        // Called after each slide's SVG is inserted (comprehensive enhancement pipeline)
        window.fixSVGLayoutAndLabels = function fixSVGLayoutAndLabels(svgEl) {
            console.log('🔧 fixSVGLayoutAndLabels called - running full enhancement pipeline');

            if (window.fixSVGLayout) {
                window.fixSVGLayout(svgEl);         // your viewBox pad step
            }
            if (window.applyLabelLayout) {
                window.applyLabelLayout(svgEl);     // space labels (greedy)
            }
            bringTextToFront(svgEl);                // labels above graphics
            styleLabels(svgEl, { use: "shadow" });  // halo + subtle shadow
            shrinkEndpoints(svgEl, 5);              // smaller bulbs globally

            console.log('   ✅ Enhancement pipeline completed');
        };

        // Auto-fix all SVGs when a slide is loaded
        window.addEventListener("slideLoaded", () => {
            console.log("📄 slideLoaded event received");
            const svgs = document.querySelectorAll("#slide-content svg");
            console.log('   Found ' + svgs.length + ' SVG(s) in slide content');

            if (svgs.length > 0) {
                // Wait for libraries to be ready before processing SVGs
                if (!window.d3 || !window.fc) {
                    console.log("⏳ Libraries not ready, waiting...");
                    waitForLibraries(() => {
                        svgs.forEach((svg, index) => {
                            console.log('   Processing SVG ' + (index + 1) + '/' + svgs.length);
                            fixSVGLayoutAndLabels(svg);
                        });
                    });
                } else {
                    svgs.forEach((svg, index) => {
                        console.log('   Processing SVG ' + (index + 1) + '/' + svgs.length);
                        fixSVGLayoutAndLabels(svg);
                    });
                }
            }
        });
    </script>

    <script>
// No embedded data needed for this presentation
console.log('Presentation loaded - no external data dependencies');


const slidesData = [{"content":"<div class='slide title-slide'> <style> /* --- Title hero layout (scoped to this slide) --- */ .title-slide { padding: 6vh 6vw 5vh; } .hero { display: grid; grid-template-columns: minmax(420px, 1.2fr) minmax(420px, .8fr); align-items: center; gap: clamp(24px, 5vw, 56px); margin-top: 2vh; } .hero-left { display: grid; gap: clamp(8px, 1vw, 14px); } .main-title { font-size: clamp(44px, 6.2vw, 88px); line-height: 1.05; margin: 0; margin-top: 0; background: linear-gradient(180deg,#b8f5ff 0%, #29f5c8 60%, #1bd49a 100%); -webkit-background-clip: text; background-clip: text; color: transparent; text-shadow: 0 10px 40px rgba(0,0,0,.25); } .kicker { margin: 0; font-size: clamp(18px, 2.2vw, 26px); font-weight: 600; display: inline-flex; align-items: center; gap: .6em; } .kicker::before { content: ''; width: .4em; height: 1.1em; border-radius: 2px; background: var(--accent2, #00e6a8); box-shadow: 0 0 10px rgba(0,230,168,.4); } .hero-right svg { width: 100%; height: auto; display: block; } .meta { margin-top: clamp(24px, 4vh, 48px); text-align: center; display: grid; gap: 8px; } /* tagline stays subtle */ .meta .tagline { opacity: .9; } /* footer logo */ .meta-logo { width: clamp(140px, 16vw, 240px); height: auto; margin: 10px auto 4px; display: block; filter: drop-shadow(0 8px 18px rgba(0, 255, 194, .15)) drop-shadow(0 2px 6px rgba(0, 0, 0, .35)); border-radius: 10px; } /* make 'Tech Talk' larger and bolder */ .meta .talk { font-size: clamp(36px, 5vw, 64px); font-weight: 700; letter-spacing: .5px; opacity: .95; } </style> <div class='hero'> <div class='hero-left'> <h1 class='main-title'>Stop Fighting Wraparound</h1> <p class='kicker'>Embed Your Rings!</p> </div> <div class='hero-right'> <!-- Bigger, cleaner SVG hero --> <svg viewBox='0 0 460 300'> <!-- circles --> <circle cx='120' cy='150' r='95' fill='none' stroke='#4CAF50' stroke-width='3'/> <circle cx='120' cy='150' r='65' fill='none' stroke='#4CAF50' stroke-opacity='.6' stroke-width='3'/> <!-- wrong linear distance --> <path d='M 185 150 L 55 150' stroke='#FF5722' stroke-width='2' stroke-dasharray='6,6' opacity='0.65'/> <text x='120' y='137' text-anchor='middle' fill='#FFB74D' font-weight='700' font-size='16'>140° apart?</text> <!-- correct arc distance --> <path d='M 185 150 A 95 95 0 0 0 55 150' fill='none' stroke='#4CAF50' stroke-width='3'/> <text x='120' y='182' text-anchor='middle' fill='#9CFFB0' font-weight='700' font-size='16'>20° apart!</text> <!-- endpoints (smaller bulbs) --> <circle cx='185' cy='150' r='5' fill='#FF5722'/> <circle cx='55' cy='150' r='5' fill='#2196F3'/> <!-- embed arrow/right panel --> <path d='M 230 150 L 310 150' stroke='#9aa4ad' stroke-width='2' marker-end='url(#arrowhead)'/> <text x='270' y='136' text-anchor='middle' fill='#c9d1d9' font-size='13'>embed</text> <g transform='translate(360,150)'> <line x1='-45' y1='0' x2='45' y2='0' stroke='#9aa4ad' stroke-width='1'/> <line x1='0' y1='-45' x2='0' y2='45' stroke='#9aa4ad' stroke-width='1'/> <circle cx='32' cy='0' r='5' fill='#FF5722'/> <circle cx='-32' cy='0' r='5' fill='#2196F3'/> <text x='0' y='-55' text-anchor='middle' fill='#c9d1d9' font-size='12'>ℝ²</text> </g> <defs> <marker id='arrowhead' markerWidth='10' markerHeight='7' refX='10' refY='3.5' orient='auto'> <polygon points='0 0, 10 3.5, 0 7' fill='#9aa4ad'/> </marker> </defs> </svg> </div> </div> <div class='meta'> <p class='tagline'>A practical guide to handling ring-like quantities in code</p> <!-- footer logo instead of the 'Ceres' text --> <img src='../ceres-tech-logo.png' alt='Ceres AI' class='meta-logo' /> <p class='talk'>Tech Talk</p> </div> </div> ","title":"Stop Fighting Wraparound"},{"content":"<div class='slide'> <h1>The Bug We've All Written</h1> <div class='highlight-box'> <h3>❌ The Naive Approach</h3> <pre><code class=\"language-python\">def average_angle(angle1, angle2):\n    return (angle1 + angle2) / 2  # Seems reasonable...\n\n# Example: Average heading between two compass readings\nheading1 = 350  # degrees\nheading2 = 10   # degrees\n\naverage = average_angle(heading1, heading2)\nprint(f\"Average: {average}°\")  # 180° - COMPLETELY WRONG!</code></pre> </div> <div class='visual-demo'> <svg width='600' height='600' viewBox='0 0 300 300'> <!-- Compass circle --> <circle cx='150' cy='150' r='120' fill='none' stroke='#333' stroke-width='2'/> <!-- Compass labels with stroke for better readability --> <text x='150' y='20' text-anchor='middle' font-size='16' font-weight='bold' fill='#FFC107' paint-order='stroke' stroke='#0b0f14' stroke-width='3'>N (0°)</text> <text x='280' y='155' text-anchor='middle' font-size='16' font-weight='bold' fill='#FFC107' paint-order='stroke' stroke='#0b0f14' stroke-width='3'>E (90°)</text> <text x='150' y='290' text-anchor='middle' font-size='16' font-weight='bold' fill='#FFC107' paint-order='stroke' stroke='#0b0f14' stroke-width='3'>S (180°)</text> <text x='20' y='155' text-anchor='middle' font-size='16' font-weight='bold' fill='#FFC107' paint-order='stroke' stroke='#0b0f14' stroke-width='3'>W (270°)</text> <!-- Heading 1: 350° --> <line x1='150' y1='150' x2='140' y2='30' stroke='#2196F3' stroke-width='4'/> <circle cx='140' cy='30' r='8' fill='#2196F3'/> <text x='110' y='20' font-size='14' fill='#FFC107'>350°</text> <!-- Heading 2: 10° --> <line x1='150' y1='150' x2='160' y2='30' stroke='#4CAF50' stroke-width='4'/> <circle cx='160' cy='30' r='8' fill='#4CAF50'/> <text x='190' y='20' font-size='14' fill='#FFC107'>10°</text> <!-- Wrong average: 180° --> <line x1='150' y1='150' x2='150' y2='270' stroke='#FF5722' stroke-width='4' stroke-dasharray='5,5'/> <circle cx='150' cy='270' r='8' fill='#FF5722'/> <text x='150' y='260' text-anchor='middle' font-size='16' fill='#FF5722' font-weight='bold'> Wrong: 180° </text> <!-- Correct average indicator --> <line x1='150' y1='150' x2='150' y2='30' stroke='#FFC107' stroke-width='3' opacity='0.7'/> <text x='220' y='60' font-size='14' fill='#ffffff' font-weight='bold'>Should be ~0°!</text> </svg> </div> <div class='warning-box'> <h3>What Went Wrong?</h3> <ul> <li>350° and 10° are <strong>20° apart</strong> on the circle</li> <li>But linear math sees them as <strong>340° apart</strong></li> <li>The average points in the <strong>opposite direction</strong>!</li> </ul> </div> </div> <script> // Fix SVG layout and labels when this slide is displayed console.log('🎯 Slide 02-the-bug script executing'); setTimeout(() => { console.log('🎯 Slide 02-the-bug timeout triggered'); const svg = document.querySelector('.visual-demo svg'); if (svg) { console.log(' Found SVG in .visual-demo'); if (window.fixSVGLayoutAndLabels) { console.log(' Calling fixSVGLayoutAndLabels from slide script'); window.fixSVGLayoutAndLabels(svg); } else { console.warn(' fixSVGLayoutAndLabels function not found on window'); } } else { console.warn(' No SVG found in .visual-demo'); } }, 100); <\\/script> ","title":"The Bug We've All Written"},{"content":"<div class='slide'> <h1>The Midnight Bug</h1> <div class='info-box'> <h3>📅 Real Scenario: Event Duration Tracking</h3> <p>Meeting started at <strong>23:45</strong> (11:45 PM)</p> <p>Meeting ended at <strong>00:15</strong> (12:15 AM)</p> </div> <div class='code-comparison'> <div class='highlight-box'> <h4>❌ What Everyone Tries First</h4> <pre><code>start_time = 23.75  # 23:45 in decimal hours\nend_time = 0.25     # 00:15 in decimal hours\n\nduration = end_time - start_time\nprint(f\"Duration: {duration} hours\")\n# Output: -23.5 hours 🤦</code></pre> </div> <div class='warning-box'> <h4>🤔 The Hacky 'Fix'</h4> <pre><code>if end_time < start_time:\n    # Must have crossed midnight\n    duration = (24 - start_time) + end_time\nelse:\n    duration = end_time - start_time\n    \n# More special cases...\nif crossed_dst:  # Daylight savings\n    duration += 1  # or -1? 😭</code></pre> </div> </div> <div class='clock-visual'> <svg width='1200' height='500' viewBox='0 0 800 300'> <!-- Linear representation --> <g transform='translate(30, 80)'> <text x='150' y='-20' text-anchor='middle' font-size='14' font-weight='bold' fill='#FFC107'>Linear View:</text> <line x1='0' y1='20' x2='300' y2='20' stroke='#333' stroke-width='2'/> <!-- Time markers --> <line x1='0' y1='15' x2='0' y2='25' stroke='#333' stroke-width='2'/> <text x='0' y='40' text-anchor='middle' font-size='12' fill='#FFC107'>0:00</text> <line x1='150' y1='15' x2='150' y2='25' stroke='#333' stroke-width='2'/> <text x='150' y='40' text-anchor='middle' font-size='12' fill='#FFC107'>12:00</text> <line x1='300' y1='15' x2='300' y2='25' stroke='#333' stroke-width='2'/> <text x='300' y='40' text-anchor='middle' font-size='12' fill='#FFC107'>24:00</text> <!-- Start time: 23:45 (23.75/24 * 300 = 296.25) --> <circle cx='296' cy='20' r='8' fill='#2196F3'/> <text x='296' y='60' text-anchor='middle' font-size='12' fill='#FFC107'>23:45</text> <!-- End time: 00:15 (0.25/24 * 300 = 3.125) --> <circle cx='3' cy='20' r='8' fill='#4CAF50'/> <text x='3' y='60' text-anchor='middle' font-size='12' fill='#FFC107'>00:15</text> <!-- Wrong distance --> <path d='M 296 20 L 3 20' stroke='#FF5722' stroke-width='2' stroke-dasharray='5,5' opacity='0.5'/> <text x='150' y='80' text-anchor='middle' fill='#FF5722' font-size='14'>Linear: -23.5 hours!</text> </g> <!-- Circular representation --> <g transform='translate(550, 150)'> <text x='0' y='-90' text-anchor='middle' font-size='14' font-weight='bold' fill='#FFC107'>Circular View:</text> <circle cx='0' cy='0' r='70' fill='none' stroke='#333' stroke-width='2'/> <!-- Clock numbers --> <text x='0' y='-55' text-anchor='middle' font-size='12' fill='#FFC107'>12</text> <text x='55' y='5' text-anchor='middle' font-size='12' fill='#FFC107'>3</text> <text x='0' y='60' text-anchor='middle' font-size='12' fill='#FFC107'>6</text> <text x='-55' y='5' text-anchor='middle' font-size='12' fill='#FFC107'>9</text> <!-- Start: 23:45 --> <line x1='0' y1='0' x2='-10' y2='-68' stroke='#2196F3' stroke-width='3'/> <circle cx='-10' cy='-68' r='8' fill='#2196F3'/> <!-- End: 00:15 --> <line x1='0' y1='0' x2='10' y2='-68' stroke='#4CAF50' stroke-width='3'/> <circle cx='10' cy='-68' r='8' fill='#4CAF50'/> <!-- Correct arc --> <path d='M -10 -68 A 70 70 0 0 1 10 -68' fill='none' stroke='#4CAF50' stroke-width='3'/> <text x='0' y='90' text-anchor='middle' fill='#4CAF50' font-size='14' font-weight='bold'> Correct: 30 minutes! </text> </g> </svg> </div> <div class='success-box'> <h3>💡 The Key Insight</h3> <p>Time-of-day is a <strong>24-hour ring</strong>, not a line!</p> <p>Linear arithmetic breaks at the wraparound point.</p> </div> </div> ","title":"The Midnight Bug"},{"content":"<div class='slide'> <h1>The Missing Math Class: Circular Operations</h1> <div class='warning-box'> <h3>🤯 What They Never Taught You</h3> <p>Circular quantities are everywhere, but traditional math classes skip the operations entirely! Here's what you can actually <strong>do</strong> once you embed them as vectors:</p> </div> <div class='two-column-equal'> <div class='card'> <h3>📊 Basic Operations</h3> <div class='operation-list'> <div class='op-item'> <strong>Addition:</strong> <code>v₁ + v₂</code><br> <small>Compose two rotations</small> </div> <div class='op-item'> <strong>Subtraction:</strong> <code>v₁ - v₂</code><br> <small>Find angular difference</small> </div> <div class='op-item'> <strong>Average:</strong> <code>mean(vectors)</code><br> <small>Circular mean (always works!)</small> </div> <div class='op-item'> <strong>Interpolation:</strong> <code>slerp(v₁, v₂, t)</code><br> <small>Smooth rotation between angles</small> </div> </div> </div> <div class='card'> <h3>🧮 Advanced Operations</h3> <div class='operation-list'> <div class='op-item'> <strong>Distance:</strong> <code>shortest_path(θ₁, θ₂)</code><br> <small>Minimal angular separation</small> </div> <div class='op-item'> <strong>Scaling:</strong> <code>scalar × vector</code><br> <small>Scale magnitude, preserve direction</small> </div> <div class='op-item'> <strong>Derivatives:</strong> <code>d/dt [cos(ωt), sin(ωt)]</code><br> <small>Angular velocity vectors</small> </div> <div class='op-item'> <strong>Integration:</strong> <code>∫ ω(t) dt</code><br> <small>Accumulate rotations over time</small> </div> </div> </div> </div> <div class='success-box'> <h3>📈 Circular Statistics (The Really Cool Stuff)</h3> <div class='code-example'> <pre><code class=\"language-python\"># Operations that actually work on circular data!\nangles = [350°, 10°, 5°, 355°]  # Wind directions\nvectors = [to_vector(θ) for θ in angles]\n\n# Circular mean (not 180°!)\nmean_vector = np.mean(vectors, axis=0) \nmean_angle = from_vector(mean_vector)  # ≈ 0°\n\n# Circular standard deviation  \ndispersion = 1 - |mean_vector|  # How \"spread out\" are they?\n\n# Circular correlation\ncorrelation = correlate_circular(wind_dir, wave_dir)\n\n# Circular regression (yes, this exists!)\nslope, intercept = circular_regression(time, wave_directions)</code></pre> </div> </div> <div class='info-box'> <h3>🎯 Why This Matters</h3> <div class='three-column'> <div> <h4>🌊 Oceanography</h4> <p>Wave directions, current flows</p> </div> <div> <h4>🧭 Navigation</h4> <p>GPS, compass bearings, flight paths</p> </div> <div> <h4>🧬 Biology</h4> <p>Circadian rhythms, animal migration</p> </div> <div> <h4>🎵 Signal Processing</h4> <p>Phase analysis, Fourier transforms</p> </div> <div> <h4>🤖 Robotics</h4> <p>Joint angles, orientation control</p> </div> <div> <h4>📊 Data Science</h4> <p>Seasonal trends, cyclic patterns</p> </div> </div> </div> <div class='highlight-box'> <h3>💡 The Big Insight</h3> <p><strong>Every operation you know from linear algebra works on circular quantities—you just need to embed them first!</strong> This is why embedding is such a powerful mathematical technique.</p> <div class='formula-showcase'> <code>Circular Quantity → Vector → Linear Operation → Vector → Circular Result</code> </div> </div> </div>","title":"The Missing Math Class: Circular Operations"},{"content":"<div class='slide'> <h1>Circular Statistics: The Hidden Superpower</h1> <div class='warning-box'> <h3>🤯 What Statistics Class Never Taught You</h3> <p>Standard statistics breaks horribly on circular data. But vector embedding makes circular statistics <strong>trivially easy</strong>—and incredibly powerful!</p> </div> <div class='two-column-equal'> <div class='card'> <h3>📊 The Problem with Regular Stats</h3> <div class='code-example'> <pre><code class=\"language-python\"># Wind directions (degrees)\nangles = [350, 10, 5, 355]\n\n# Regular mean = DISASTER\nmean = sum(angles) / len(angles)  # = 180°\n# 180° is the OPPOSITE direction! 🤦‍♂️\n\n# Regular standard deviation = MEANINGLESS\nstd = numpy.std(angles)  # = 187°\n# Standard deviation larger than the range!</code></pre> </div> </div> <div class='card'> <h3>✨ Vector Statistics = Magic</h3> <div class='code-example'> <pre><code class=\"language-python\"># Convert to vectors\nvectors = [angle_to_vector(θ) for θ in angles]\n\n# Circular mean = WORKS!\nmean_vector = np.mean(vectors, axis=0)\nmean_angle = vector_to_angle(mean_vector)  # ≈ 0°\n# Correct direction! 🎯\n\n# Circular standard deviation\nR = |mean_vector|  # Mean vector length\ncircular_std = sqrt(-2 * log(R))  # ≈ 22°\n# Sensible measure of spread!</code></pre> </div> </div> </div> <div class='info-box'> <h3>🧠 The Key Insight: Mean Vector Length</h3> <div class='two-column'> <div class='visual-element'> <svg width='300' height='200' viewBox='0 0 300 200'> <!-- Tight cluster --> <g transform='translate(75, 100)'> <circle r='50' fill='none' stroke='#666' stroke-width='1' opacity='0.3'/> <!-- Data points clustered tightly --> <circle cx='45' cy='5' r='4' fill='#4CAF50'/> <circle cx='47' cy='-3' r='4' fill='#4CAF50'/> <circle cx='43' cy='3' r='4' fill='#4CAF50'/> <circle cx='46' cy='0' r='4' fill='#4CAF50'/> <!-- Strong mean vector --> <path d='M 0 0 L 40 0' stroke='#FF5722' stroke-width='4' marker-end='url(#arrow)'/> <text x='0' y='-65' text-anchor='middle' fill='#4CAF50' font-size='12'>Tight Cluster</text> <text x='0' y='75' text-anchor='middle' fill='#FF5722' font-size='11'>|R| ≈ 0.95</text> <text x='0' y='87' text-anchor='middle' fill='#666' font-size='10'>Low variance</text> </g> <!-- Spread out data --> <g transform='translate(225, 100)'> <circle r='50' fill='none' stroke='#666' stroke-width='1' opacity='0.3'/> <!-- Data points spread out --> <circle cx='45' cy='5' r='4' fill='#2196F3'/> <circle cx='-30' cy='35' r='4' fill='#2196F3'/> <circle cx='-15' cy='-45' r='4' fill='#2196F3'/> <circle cx='20' cy='-40' r='4' fill='#2196F3'/> <!-- Weak mean vector --> <path d='M 0 0 L 8 -5' stroke='#FF5722' stroke-width='4' marker-end='url(#arrow)'/> <text x='0' y='-65' text-anchor='middle' fill='#2196F3' font-size='12'>Spread Out</text> <text x='0' y='75' text-anchor='middle' fill='#FF5722' font-size='11'>|R| ≈ 0.1</text> <text x='0' y='87' text-anchor='middle' fill='#666' font-size='10'>High variance</text> </g> <defs> <marker id='arrow' markerWidth='10' markerHeight='7' refX='10' refY='3.5' orient='auto'> <polygon points='0 0, 10 3.5, 0 7' fill='#FF5722'/> </marker> </defs> </svg> </div> <div> <h4>💡 The Beautiful Truth</h4> <div class='formula-showcase'> <p><strong>Tight cluster:</strong> Mean vector is long (|R| → 1)</p> <p><strong>Spread out:</strong> Mean vector is short (|R| → 0)</p> <p><strong>Uniform circle:</strong> Mean vector ≈ 0</p> </div> <p>The length of the mean vector automatically captures how 'concentrated' your circular data is!</p> </div> </div> </div> <div class='success-box'> <h3>🔬 Advanced Circular Stats That Actually Work</h3> <div class='code-example'> <pre><code class=\"language-python\"># Circular correlation between two angular variables\ndef circular_correlation(angles1, angles2):\n    v1 = [angle_to_vector(θ) for θ in angles1]\n    v2 = [angle_to_vector(θ) for θ in angles2]\n    # Standard correlation on the vector components\n    return pearsonr(v1, v2)\n\n# Circular regression (yes, this exists!)\ndef circular_regression(x, circular_y):\n    vectors_y = [angle_to_vector(θ) for θ in circular_y]\n    # Regress each component separately\n    cos_model = LinearRegression().fit(x, [v[0] for v in vectors_y])\n    sin_model = LinearRegression().fit(x, [v[1] for v in vectors_y])\n    return cos_model, sin_model\n\n# Watson-Williams test (circular ANOVA)\n# Test if multiple groups have the same mean direction\ndef watson_williams_test(group1_angles, group2_angles):\n    # Convert to vectors, compute mean directions, test significance\n    # (This is the circular equivalent of a t-test!)</code></pre> </div> </div> <div class='highlight-box'> <h3>🌟 Real-World Applications</h3> <div class='three-column'> <div> <h4>🧬 Biology</h4> <p><strong>Animal migration:</strong> Test if birds change direction by season</p> <p><strong>Circadian rhythms:</strong> Correlate activity with time of day</p> </div> <div> <h4>🌊 Earth Sciences</h4> <p><strong>Wind patterns:</strong> Seasonal wind direction changes</p> <p><strong>Ocean currents:</strong> Correlation with tidal cycles</p> </div> <div> <h4>🎵 Signal Processing</h4> <p><strong>Phase analysis:</strong> Correlation between signal phases</p> <p><strong>Circular convolution:</strong> Periodic signal filtering</p> </div> </div> </div> </div>","title":"Circular Statistics: The Hidden Superpower"},{"content":"<div class='slide'> <h1>Discrete Calculus on Circles: Data-Driven Operations</h1> <div class='info-box'> <h3>📊 Real-World Data = Discrete Samples</h3> <p>In practice, we don't have continuous functions—we have <strong>time series data</strong> of circular quantities. How do we compute derivatives and integrals when our data wraps around?</p> </div> <div class='two-column-equal'> <div class='card'> <h3>📈 Discrete Derivatives (Angular Velocity)</h3> <div class='code-example'> <pre><code class=\"language-python\"># WRONG: Naive difference breaks at wraparound\nangles = [358°, 359°, 1°, 2°]  # Smooth rotation\nnaive_diff = [1°, 2°, -357°]  # HUGE SPIKE! 💥\n\n# RIGHT: Vector space derivative\nvectors = [(cos(θ), sin(θ)) for θ in angles]\ndvdt = [(v[i+1] - v[i])/dt for i in range(len(v)-1)]\n\n# Angular velocity from vector derivative\nω = cross_product(v[i], dvdt[i]) / |v[i]|²\n# Result: [1°/s, 1°/s, 1°/s] ✅</code></pre> </div> </div> <div class='card'> <h3>📉 Discrete Integrals (Accumulated Rotation)</h3> <div class='code-example'> <pre><code class=\"language-python\"># WRONG: Sum angles directly\nangular_velocities = [90°/s, 90°/s, 90°/s, 90°/s]\nnaive_sum = sum(angular_velocities) * dt  # 360°???\n\n# RIGHT: Accumulate in vector space\nv_accumulated = [1, 0]  # Start at 0°\nfor ω in angular_velocities:\n    # Rotate vector by angular increment\n    dθ = ω * dt\n    rotation = [[cos(dθ), -sin(dθ)],\n                [sin(dθ), cos(dθ)]]\n    v_accumulated = rotation @ v_accumulated\n\nfinal_angle = atan2(v_accumulated)  # Correct!</code></pre> </div> </div> </div> <div class='success-box'> <h3>🔧 Practical Applications in Data Science</h3> <div class='two-column'> <div> <h4>🌊 Wind Speed Analysis</h4> <div class='code-example'> <pre><code class=\"language-python\"># Wind direction time series (sampled every hour)\nwind_dirs = [350°, 355°, 0°, 5°, 10°]  # North-ish\nwind_speeds = [10, 12, 15, 14, 11]  # mph\n\n# Compute wind vector components\nu = [-speed * sin(dir) for speed, dir in zip(wind_speeds, wind_dirs)]\nv = [-speed * cos(dir) for speed, dir in zip(wind_speeds, wind_dirs)]\n\n# Now can compute proper derivatives!\ndu_dt = np.gradient(u)  # Wind acceleration (east)\ndv_dt = np.gradient(v)  # Wind acceleration (north)</code></pre> </div> </div> <div> <h4>🤖 Robot Heading Tracking</h4> <div class='code-example'> <pre><code class=\"language-python\"># IMU gives heading samples at 100Hz\nheadings = sensor.get_heading_buffer()  # [θ₁, θ₂, ..., θₙ]\ndt = 0.01  # 10ms between samples\n\n# Convert to unit vectors\nvectors = [(cos(h), sin(h)) for h in headings]\n\n# Compute angular velocity using discrete derivative\nangular_vel = []\nfor i in range(len(vectors)-1):\n    # Cross product gives rotation rate\n    ω = (vectors[i][0]*vectors[i+1][1] - \n         vectors[i][1]*vectors[i+1][0]) / dt\n    angular_vel.append(ω)\n\n# Smooth using windowed average (no wraparound issues!)\nsmoothed_ω = moving_average(angular_vel, window=10)</code></pre> </div> </div> </div> </div> <div class='warning-box'> <h3>⚠️ Common Pitfalls with Discrete Circular Data</h3> <div class='three-column'> <div> <h4>❌ Phase Unwrapping</h4> <p><code>unwrap([350°, 10°])</code> → <code>[350°, 370°]</code></p> <p>Creates artificial trends! Use vectors instead.</p> </div> <div> <h4>❌ Modulo Arithmetic</h4> <p><code>(θ₂ - θ₁) % 360</code></p> <p>Loses direction info. Vector difference preserves it.</p> </div> <div> <h4>❌ Averaging Raw Angles</h4> <p><code>mean([0°, 90°, 180°, 270°])</code> → <code>135°</code></p> <p>Should be undefined! Vector mean → 0.</p> </div> </div> </div> <div class='highlight-box'> <h3>🎯 The Key Pattern for Discrete Operations</h3> <div class='formula-showcase'> <div style='text-align: center; padding: 20px;'> <p style='font-size: 18px; margin: 10px 0;'> <strong>Discrete Samples</strong> → <strong>Vector Time Series</strong> → <strong>Standard Numpy Operations</strong> → <strong>Interpret Results</strong> </p> <p style='margin-top: 20px;'> <code>θ[t]</code> → <code>[cos(θ[t]), sin(θ[t])]</code> → <code>np.gradient(), np.cumsum()</code> → <code>atan2() if needed</code> </p> </div> </div> <p><strong>Bottom Line:</strong> NumPy/Pandas operations 'just work' on vector representations—no special circular functions needed!</p> </div> </div>","title":"Discrete Calculus on Circles: Data-Driven Operations"},{"content":"<div class='slide'> <h1>Hidden Rings Everywhere: Beyond Angles & Time</h1> <div class='warning-box'> <h3>🔍 Circular Quantities Hide in Plain Sight</h3> <p>It's not just angles, time, and colors that wrap around. Here are the sneaky cyclic variables that cause bugs when you least expect them:</p> </div> <div class='pattern-table'> <table style='width: 100%; border-collapse: collapse;'> <thead> <tr style='background: rgba(33, 150, 243, 0.1); border-bottom: 2px solid #2196F3;'> <th style='padding: 12px; text-align: left; width: 30%;'>Domain</th> <th style='padding: 12px; text-align: left; width: 35%;'>❌ Where Naive Math Fails</th> <th style='padding: 12px; text-align: left; width: 35%;'>✅ Correct Embedding</th> </tr> </thead> <tbody> <tr style='border-bottom: 1px solid #444;'> <td style='padding: 10px;'><strong>📅 Weekdays</strong><br><code>d ∈ {0..6}</code></td> <td style='padding: 10px;'>Mean of Sat(6) and Mon(1) = 3.5 (Wed)?<br><span style='color: #FF5722;'>Wrong! Should be Sunday</span></td> <td style='padding: 10px;'><code>(cos(2πd/7), sin(2πd/7))</code></td> </tr> <tr style='border-bottom: 1px solid #444; background: rgba(255, 255, 255, 0.02);'> <td style='padding: 10px;'><strong>🔧 Rotary Encoders</strong><br><code>n ∈ [0, 4096)</code></td> <td style='padding: 10px;'>4095 → 1 looks like −4094 ticks<br><span style='color: #FF5722;'>Actually just 2 ticks forward!</span></td> <td style='padding: 10px;'><code>(cos(2πn/N), sin(2πn/N))</code></td> </tr> <tr style='border-bottom: 1px solid #444;'> <td style='padding: 10px;'><strong>🌍 Longitude</strong><br><code>λ ∈ [−180°, 180°)</code></td> <td style='padding: 10px;'>Mean of 179°E and 179°W = 0°?<br><span style='color: #FF5722;'>Points are 2° apart, not at Greenwich!</span></td> <td style='padding: 10px;'>3D vectors on sphere:<br><code>(cos(lat)cos(lon), cos(lat)sin(lon), sin(lat))</code></td> </tr> <tr style='border-bottom: 1px solid #444; background: rgba(255, 255, 255, 0.02);'> <td style='padding: 10px;'><strong>📡 Signal Phase</strong><br><code>φ ∈ [−π, π)</code></td> <td style='padding: 10px;'>Phase unwrapping creates artificial jumps<br><span style='color: #FF5722;'>Destroys true periodicity</span></td> <td style='padding: 10px;'>Complex: <code>e<sup>iφ</sup> = cos(φ) + i·sin(φ)</code></td> </tr> <tr style='border-bottom: 1px solid #444;'> <td style='padding: 10px;'><strong>💍 Ring Buffers</strong><br><code>idx ∈ [0, size)</code></td> <td style='padding: 10px;'><code>tail - head</code> wrong when wrapped<br><span style='color: #FF5722;'>Buffer looks full when nearly empty!</span></td> <td style='padding: 10px;'><code>(idx + size) % size</code><br>or embed as angle</td> </tr> <tr style='border-bottom: 1px solid #444; background: rgba(255, 255, 255, 0.02);'> <td style='padding: 10px;'><strong>⚙️ Gear Teeth</strong><br><code>tooth ∈ [0, N)</code></td> <td style='padding: 10px;'>Tooth 0 and Tooth N-1 look maximally apart<br><span style='color: #FF5722;'>They're actually neighbors!</span></td> <td style='padding: 10px;'><code>(cos(2πt/N), sin(2πt/N))</code></td> </tr> <tr style='border-bottom: 1px solid #444;'> <td style='padding: 10px;'><strong>🧬 Circadian Phase</strong><br><code>t ∈ [0, 24h)</code></td> <td style='padding: 10px;'>Sleep at 23:00 and 01:00 averages to noon?<br><span style='color: #FF5722;'>Should be midnight!</span></td> <td style='padding: 10px;'><code>(cos(2πt/24), sin(2πt/24))</code></td> </tr> <tr style='border-bottom: 1px solid #444; background: rgba(255, 255, 255, 0.02);'> <td style='padding: 10px;'><strong>📊 Months of Year</strong><br><code>m ∈ {1..12}</code></td> <td style='padding: 10px;'>Dec(12) to Jan(1) = -11 months?<br><span style='color: #FF5722;'>Just 1 month forward!</span></td> <td style='padding: 10px;'><code>(cos(2πm/12), sin(2πm/12))</code></td> </tr> </tbody> </table> </div> <div class='highlight-box'> <h3>💡 The Universal Solution</h3> <div class='formula-showcase'> <p style='text-align: center; font-size: 18px; margin: 15px 0;'> <strong>For ANY cyclic quantity with period T starting at offset s:</strong> </p> <p style='text-align: center; font-size: 20px; background: rgba(76, 175, 80, 0.1); padding: 15px; border-radius: 8px;'> <code>θ = 2π(value - s)/T</code> → <code>(cos(θ), sin(θ))</code> </p> <p style='text-align: center; margin-top: 15px;'> Do all your math in vector space, then project back if needed! </p> </div> </div> <div class='info-box'> <h3>🎯 When to Suspect a Hidden Ring</h3> <div class='two-column'> <div> <h4>🚩 Red Flags in Your Data</h4> <ul> <li>Values that 'roll over' or 'wrap'</li> <li>Modulo operations in the code</li> <li>Special cases for 'crossing midnight'</li> <li>Discontinuous jumps in time series</li> <li>'Distance' that depends on direction</li> </ul> </div> <div> <h4>🐛 Classic Bug Patterns</h4> <ul> <li>Averages that are wildly wrong</li> <li>Interpolation that takes the 'long way'</li> <li>Derivatives with impossible spikes</li> <li>Sorting that puts neighbors far apart</li> <li>Clustering that splits natural groups</li> </ul> </div> </div> </div> </div>","title":"Hidden Rings Everywhere: Beyond Angles & Time"},{"content":"<div class='slide'> <h1>When Zero Isn't Special: Arbitrary Wrap Points</h1> <div class='warning-box'> <h3>🎯 Real Hardware Doesn't Care About Zero</h3> <p>Many circular quantities in the wild wrap at arbitrary values, not nice round numbers. The math still works—you just need to normalize first!</p> </div> <div class='two-column-equal'> <div class='card'> <h3>📊 Common Non-Zero Wrap Domains</h3> <div class='example-list'> <div class='example-item'> <h4>🧭 Compass: [-180°, +180°)</h4> <p>Wraps at ±180°, not 0°/360°</p> <code>bearing ∈ [-180, 180)</code> </div> <div class='example-item'> <h4>🔧 Rotary Encoder: [1000, 5096)</h4> <p>12-bit encoder with arbitrary offset</p> <code>counts ∈ [1000, 5096)</code> </div> <div class='example-item'> <h4>📡 Phase: [-π, +π)</h4> <p>Centered around zero, not starting at it</p> <code>phase ∈ [-π, π)</code> </div> <div class='example-item'> <h4>🗓️ Fiscal Year: [Apr, Mar]</h4> <p>Wraps at March/April boundary</p> <code>month ∈ [4, 3] (mod 12)</code> </div> <div class='example-item'> <h4>🌡️ ADC Values: [512, 3584)</h4> <p>Sensor with DC offset and limited range</p> <code>adc ∈ [512, 3584)</code> </div> </div> </div> <div class='card'> <h3>✨ The Universal Transform</h3> <div class='formula-showcase' style='background: rgba(76, 175, 80, 0.1); padding: 20px; border-radius: 8px; margin: 20px 0;'> <h4>For any circular quantity:</h4> <p><code>value ∈ [min, max)</code></p> <p style='margin: 15px 0;'>↓</p> <p><strong>1. Normalize to [0, 1):</strong></p> <p><code>t = (value - min) / (max - min)</code></p> <p style='margin: 15px 0;'>↓</p> <p><strong>2. Embed on unit circle:</strong></p> <p><code>v = (cos(2πt), sin(2πt))</code></p> <p style='margin: 15px 0;'>↓</p> <p><strong>3. Do your math in ℝ²</strong></p> <p style='margin: 15px 0;'>↓</p> <p><strong>4. Project back if needed:</strong></p> <p><code>result = min + (max-min) × atan2(v.y, v.x)/(2π)</code></p> </div> </div> </div> <div class='success-box'> <h3>💻 Code Example: Averaging Compass Bearings</h3> <div class='code-example'> <pre><code class=\"language-python\"># PROBLEM: Compass uses [-180°, +180°) not [0°, 360°)\nbearings = [170, 175, -175, -170]  # All pointing roughly south\n\n# WRONG: Simple average\nnaive_mean = np.mean(bearings)  # = 0° (North!) 🤦\n\n# RIGHT: Normalize → Embed → Average → Denormalize\ndef circular_mean(values, min_val, max_val):\n    # Step 1: Normalize to [0, 1)\n    period = max_val - min_val\n    normalized = [(v - min_val) / period for v in values]\n    \n    # Step 2: Embed on circle\n    vectors = [(np.cos(2*np.pi*t), np.sin(2*np.pi*t)) for t in normalized]\n    \n    # Step 3: Average in vector space\n    mean_vector = np.mean(vectors, axis=0)\n    \n    # Step 4: Project back to original domain\n    angle = np.atan2(mean_vector[1], mean_vector[0])\n    result = min_val + (angle / (2*np.pi)) * period\n    if result < min_val:\n        result += period\n    return result\n\ncorrect_mean = circular_mean(bearings, -180, 180)  # ≈ 175° South! ✅</code></pre> </div> </div> <div class='info-box'> <h3>🔧 Practical Examples</h3> <div class='three-column'> <div> <h4>🎮 Game Development</h4> <div class='code-snippet'> <pre><code># Joystick angle ∈ [-π, π]\njs_angle = atan2(js.y, js.x)\n# Don't compare directly!\n# Normalize first</code></pre> </div> </div> <div> <h4>🤖 Robotics</h4> <div class='code-snippet'> <pre><code># Encoder wraps at 8192\n# but starts at 1000\nactual_pos = 1000 + \n  (raw - 1000) % 7192</code></pre> </div> </div> <div> <h4>📊 Time Series</h4> <div class='code-snippet'> <pre><code># Fiscal quarters Q2-Q1\n# April = month 0\nfiscal_month = \n  (cal_month - 4) % 12</code></pre> </div> </div> </div> </div> <div class='highlight-box'> <h3>🎯 Key Insight</h3> <p style='font-size: 18px; text-align: center; margin: 20px 0;'> <strong>The 'zero point' is arbitrary!</strong> What matters is the <em>topology</em>—that values wrap around. </p> <p style='text-align: center;'> Always normalize to [0, 1) or [0, 2π) before embedding. Your vector math doesn't care where the original wrap point was. </p> </div> </div>","title":"When Zero Isn't Special: Arbitrary Wrap Points"},{"content":"<div class='slide'> <h1>Real Example: Robot/Drone Heading Control</h1> <div class='problem-setup'> <h3>🤖 The Scenario</h3> <p>PID controller needs to turn robot from 350° to 10°</p> </div> <div class='visual-comparison'> <div class='approach bad-approach'> <h4>❌ Naive PID Error</h4> <svg width='500' height='500' viewBox='0 0 250 250'> <circle cx='125' cy='125' r='100' fill='none' stroke='#333' stroke-width='2'/> <!-- Current heading: 350° --> <line x1='125' y1='125' x2='115' y2='25' stroke='#2196F3' stroke-width='4'/> <circle cx='115' cy='25' r='6' fill='#2196F3'/> <text x='75' y='15' font-size='12' fill='#FFC107'>Current: 350°</text> <!-- Target heading: 10° --> <line x1='125' y1='125' x2='135' y2='25' stroke='#4CAF50' stroke-width='4'/> <circle cx='135' cy='25' r='6' fill='#4CAF50'/> <text x='175' y='15' font-size='12' fill='#FFC107'>Target: 10°</text> <!-- Wrong rotation path --> <path d='M 115 25 A 100 100 0 1 1 135 25' fill='none' stroke='#FF5722' stroke-width='3' stroke-dasharray='5,5'/> <text x='125' y='200' text-anchor='middle' font-size='14' fill='#FF5722' font-weight='bold'> Error: -340° </text> <text x='125' y='220' text-anchor='middle' font-size='12' fill='#FF5722'> Spins backward! </text> </svg> <pre><code>error = target - current\nerror = 10 - 350 = -340°\n# Robot spins almost full circle\n# the wrong way!</code></pre> </div> <div class='approach good-approach'> <h4>✅ Embedded Solution</h4> <svg width='500' height='500' viewBox='0 0 250 250'> <circle cx='125' cy='125' r='100' fill='none' stroke='#333' stroke-width='2'/> <!-- Current heading: 350° --> <line x1='125' y1='125' x2='115' y2='25' stroke='#2196F3' stroke-width='4'/> <circle cx='115' cy='25' r='6' fill='#2196F3'/> <text x='75' y='15' font-size='12' fill='#FFC107'>Current: 350°</text> <!-- Target heading: 10° --> <line x1='125' y1='125' x2='135' y2='25' stroke='#4CAF50' stroke-width='4'/> <circle cx='135' cy='25' r='6' fill='#4CAF50'/> <text x='175' y='15' font-size='12' fill='#FFC107'>Target: 10°</text> <!-- Correct rotation path --> <path d='M 115 25 A 100 100 0 0 1 135 25' fill='none' stroke='#4CAF50' stroke-width='3'/> <text x='125' y='200' text-anchor='middle' font-size='14' fill='#4CAF50' font-weight='bold'> Error: +20° </text> <text x='125' y='220' text-anchor='middle' font-size='12' fill='#4CAF50'> Efficient turn! </text> </svg> <pre><code>def heading_error(current, target):\n    c_vec = [cos(current), sin(current)]\n    t_vec = [cos(target), sin(target)]\n    return atan2(cross(c_vec, t_vec), \n                 dot(c_vec, t_vec))\n# Returns: +20° (shortest path!)</code></pre> </div> </div> <div class='implementation'> <h3>Complete PID Controller Fix</h3> <pre><code class=\"language-python\">class HeadingController:\n    def __init__(self, kp=1.0, ki=0.1, kd=0.05):\n        self.kp, self.ki, self.kd = kp, ki, kd\n        self.integral = 0\n        self.last_error = 0\n        \n    def compute_control(self, current_heading, target_heading, dt):\n        # Embed both headings as vectors\n        current_vec = np.array([np.cos(current_heading), np.sin(current_heading)])\n        target_vec = np.array([np.cos(target_heading), np.sin(target_heading)])\n        \n        # Compute signed angle error (always shortest path)\n        error = np.arctan2(\n            current_vec[0] * target_vec[1] - current_vec[1] * target_vec[0],\n            current_vec[0] * target_vec[0] + current_vec[1] * target_vec[1]\n        )\n        \n        # Standard PID computation (now with correct error!)\n        self.integral += error * dt\n        derivative = (error - self.last_error) / dt\n        \n        control = self.kp * error + self.ki * self.integral + self.kd * derivative\n        self.last_error = error\n        \n        return control  # Angular velocity command</code></pre> </div> <div class='impact-note'> <p>💰 <strong>Real Impact:</strong> Shipping routes crossing the Pacific get drawn spanning ~359° longitude instead of the short ~20 nautical mile path due to antimeridian wraparound bugs in mapping SDKs</p> </div> </div> ","title":"Real Example: Robot/Drone Heading Control"},{"content":"<div class='slide color-interpolation'> <style> /* Scoped styles for color interpolation slide */ .color-interpolation { padding: 2vh 3vw; display: flex; flex-direction: column; gap: 1.5vh; } .color-interpolation h1 { font-size: clamp(24px, 3vw, 40px); margin: 0 0 1vh 0; text-align: center; background: linear-gradient(135deg, #ff6b6b, #4ecdc4); -webkit-background-clip: text; background-clip: text; color: transparent; } .color-interpolation .card { background: rgba(255, 255, 255, 0.04); border: 1px solid rgba(255, 255, 255, 0.09); border-radius: 14px; padding: 14px 16px; margin-bottom: 1vh; } .color-interpolation .drag-wrap { display: grid; grid-template-columns: 420px 1fr; gap: 28px; align-items: start; flex: 1; } @media (max-width: 960px) { .color-interpolation .drag-wrap { grid-template-columns: 1fr; } } .color-interpolation .drag-wheel { position: relative; width: 400px; height: 400px; margin: 0 auto; } .color-interpolation .drag-wheel .wheel { position: absolute; inset: 0; border-radius: 50%; /* Rotated -90deg: red is now at North (0°) */ background: conic-gradient( from -90deg, hsl(0, 100%, 50%), hsl(60, 100%, 50%), hsl(120, 100%, 50%), hsl(180, 100%, 50%), hsl(240, 100%, 50%), hsl(300, 100%, 50%), hsl(360, 100%, 50%) ); box-shadow: 0 10px 26px rgba(0, 0, 0, 0.35); } /* Concentric inner mask to make a neat ring (no offset) */ .color-interpolation .drag-wheel .mask { position: absolute; inset: 42px; background: #0b1117; border-radius: 50%; box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.08); pointer-events: none; } .color-interpolation .drag-wheel svg { position: absolute; inset: 0; overflow: visible; } .color-interpolation .legend2 { display: grid; gap: 8px; color: #cfe0f1; font-size: 14px; } .color-interpolation .chip-row { display: flex; gap: 14px; align-items: center; flex-wrap: wrap; } .color-interpolation .chip { display: inline-flex; align-items: center; gap: 8px; padding: 6px 10px; border: 1px solid rgba(255, 255, 255, 0.12); border-radius: 10px; background: rgba(255, 255, 255, 0.02); } .color-interpolation .dot { width: 12px; height: 12px; border-radius: 50%; display: inline-block; box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.35) inset; } .color-interpolation .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono', monospace; } .color-interpolation .midbars { display: grid; gap: 8px; margin-top: 10px; } .color-interpolation .midbars .bar { height: 18px; border: 1px solid rgba(255, 255, 255, 0.12); border-radius: 10px; } </style> <h1>Drag the Hues on the Wheel</h1> <div class='card'> <p> Drag the two handles <strong>A</strong> and <strong>B</strong> on the hue wheel. The vectors are colored by their hues. We show two 'midpoints': the <strong>correct circular midpoint</strong> (shortest arc, <code>t=0.5</code>) and the <strong>naive linear midpoint</strong> (just averaging numbers). Watch how naive linear often cuts through unrelated hues. </p> </div> <div class='drag-wrap'> <div class='drag-wheel' aria-label='Hue wheel with draggable handles'> <div class='wheel'></div> <div class='mask'></div> <svg id='dwSVG' viewBox='0 0 400 400' width='400' height='400'> <defs> <filter id='vec-shadow'> <feDropShadow dx='0' dy='1' stdDeviation='1.2' flood-color='#000' flood-opacity='.65' /> </filter> </defs> <!-- guide ring --> <circle cx='200' cy='200' r='179' fill='none' stroke='rgba(255,255,255,.22)' stroke-width='1' /> <!-- arc between A and B (shortest arc) --> <path id='dwArc' d='' fill='none' stroke='#FFD180' stroke-width='5' stroke-linecap='round' stroke-dasharray='6,7' opacity='.9' /> <!-- vectors --> <g id='vecA' filter='url(#vec-shadow)'> <line id='lineA' x1='200' y1='200' x2='200' y2='42' stroke='#fff' stroke-width='7' /> <circle id='handleA' cx='200' cy='42' r='9' fill='#fff' stroke='rgba(0,0,0,.5)' stroke-width='2' /> <text id='labelA' x='200' y='28' text-anchor='middle' fill='#e6eef9' font-size='13' > A </text> </g> <g id='vecB' filter='url(#vec-shadow)'> <line id='lineB' x1='200' y1='200' x2='200' y2='42' stroke='#fff' stroke-width='7' /> <circle id='handleB' cx='200' cy='42' r='9' fill='#fff' stroke='rgba(0,0,0,.5)' stroke-width='2' /> <text id='labelB' x='200' y='28' text-anchor='middle' fill='#e6eef9' font-size='13' > B </text> </g> <!-- correct midpoint vector --> <g id='vecMid' filter='url(#vec-shadow)'> <line id='lineMid' x1='200' y1='200' x2='200' y2='42' stroke='#fff' stroke-width='7' /> <circle id='handleMid' cx='200' cy='42' r='9' fill='#fff' stroke='rgba(0,0,0,.5)' stroke-width='2' /> <text id='labelMid' x='200' y='28' text-anchor='middle' fill='#e6eef9' font-size='13' > circular mid </text> </g> <!-- naive midpoint vector --> <g id='vecNaive' filter='url(#vec-shadow)'> <line id='lineNaive' x1='200' y1='200' x2='200' y2='42' stroke='#fff' stroke-width='5' stroke-dasharray='4,6' /> <circle id='handleNaive' cx='200' cy='42' r='7' fill='#fff' stroke='rgba(0,0,0,.5)' stroke-width='2' /> <text id='labelNaive' x='200' y='28' text-anchor='middle' fill='#e6eef9' font-size='12' > naive mid </text> </g> </svg> </div> <div class='legend2'> <div class='chip-row'> <div class='chip'> <span class='dot' id='dotA'></span> <span class='mono'>A: <span id='degA'>0°</span></span> </div> <div class='chip'> <span class='dot' id='dotB'></span> <span class='mono'>B: <span id='degB'>0°</span></span> </div> <div class='chip'> <span class='dot' id='dotMid'></span> <span class='mono' >Circular mid (t=0.5): <span id='degMid'>0°</span></span > </div> <div class='chip'> <span class='dot' id='dotNaive'></span> <span class='mono'>Naive mid: <span id='degNaive'>0°</span></span> </div> </div> <div class='midbars'> <div class='bar' id='barCircular' title='Circular midpoint path'></div> <small> Correct (circular): follows the shorter arc between A and B. </small> <div class='bar' id='barNaive' title='Naive midpoint colors'></div> <small> Naive (linear hue numbers): can jump across unrelated hues. </small> </div> </div> </div> </div> ","title":"Drag the Hues on the Wheel"},{"content":"<div class='slide'> <h1>The General Pattern</h1> <div class='pattern-table'> <h3>Any Circular Quantity Can Be Embedded!</h3> <table> <thead> <tr> <th>Wraparound Quantity</th> <th>Traditional Problems</th> <th>Embedding Solution</th> <th>Benefits</th> </tr> </thead> <tbody> <tr> <td><strong>Angle</strong><br>θ ∈ [0, 2π)</td> <td>Gimbal lock, discontinuities</td> <td>(cos θ, sin θ) ∈ ℝ²</td> <td>Smooth interpolation</td> </tr> <tr> <td><strong>Time of Day</strong><br>t ∈ [0, 24)</td> <td>Midnight wraparound</td> <td>(cos 2πt/24, sin 2πt/24)</td> <td>No special cases</td> </tr> <tr> <td><strong>Day of Week</strong><br>d ∈ {0..6}</td> <td>Weekend averaging</td> <td>e^(2πid/7) or 7D one-hot</td> <td>Correct statistics</td> </tr> <tr> <td><strong>Phase</strong><br>φ ∈ [-π, π)</td> <td>Phase unwrapping</td> <td>e^(iφ) ∈ ℂ</td> <td>Natural operations</td> </tr> <tr> <td><strong>Encoder Position</strong><br>n ∈ [0, 4096)</td> <td>Rollover detection</td> <td>(cos 2πn/4096, sin 2πn/4096)</td> <td>Continuous tracking</td> </tr> </tbody> </table> </div> <div class='universal-class'> <h3>One Class to Rule Them All</h3> <pre><code class=\"language-python\">class CircularQuantity:\n    \"\"\"Universal handler for any quantity that wraps around\"\"\"\n    \n    def __init__(self, value, period):\n        self.period = period\n        self.value = value % period  # Normalize to [0, period)\n        \n        # THE KEY: Embed on unit circle\n        theta = 2 * np.pi * self.value / period\n        self.vec = np.array([np.cos(theta), np.sin(theta)])\n    \n    def shortest_distance_to(self, other):\n        \"\"\"Always returns shortest signed distance\"\"\"\n        angle = np.arctan2(\n            self.vec[0] * other.vec[1] - self.vec[1] * other.vec[0],\n            self.vec[0] * other.vec[0] + self.vec[1] * other.vec[1]\n        )\n        return angle * self.period / (2 * np.pi)\n    \n    def average_with(self, others):\n        \"\"\"Proper circular mean\"\"\"\n        all_vecs = [self.vec] + [o.vec for o in others]\n        mean_vec = np.mean(all_vecs, axis=0)\n        mean_vec /= np.linalg.norm(mean_vec)  # Renormalize\n        \n        angle = np.arctan2(mean_vec[1], mean_vec[0])\n        mean_value = angle * self.period / (2 * np.pi)\n        return CircularQuantity(mean_value, self.period)\n    \n    def interpolate_to(self, other, t):\n        \"\"\"Smooth interpolation along shortest path\"\"\"\n        # SLERP for perfect circular interpolation\n        dot = np.dot(self.vec, other.vec)\n        omega = np.arccos(np.clip(dot, -1, 1))\n        \n        if abs(omega) < 1e-10:  # Vectors are identical\n            return self\n        \n        vec_t = (np.sin((1-t)*omega)/np.sin(omega) * self.vec +\n                 np.sin(t*omega)/np.sin(omega) * other.vec)\n        \n        angle = np.arctan2(vec_t[1], vec_t[0])\n        value = angle * self.period / (2 * np.pi)\n        return CircularQuantity(value, self.period)</code></pre> </div> <div class='examples-grid'> <div class='example'> <h4>📐 Angles</h4> <pre><code>a1 = CircularQuantity(350, 360)\na2 = CircularQuantity(10, 360)\ndist = a1.shortest_distance_to(a2)\n# Result: 20°</code></pre> </div> <div class='example'> <h4>⏰ Time</h4> <pre><code>t1 = CircularQuantity(23.5, 24)\nt2 = CircularQuantity(0.5, 24)\navg = t1.average_with([t2])\n# Result: 0.0 (midnight)</code></pre> </div> <div class='example'> <h4>📅 Weekdays</h4> <pre><code>days = [CircularQuantity(6, 7),  # Sat\n        CircularQuantity(0, 7),  # Sun\n        CircularQuantity(1, 7)]  # Mon\navg = days[0].average_with(days[1:])\n# Result: 0 (Sunday)</code></pre> </div> <div class='example'> <h4>🔄 Encoder</h4> <pre><code>e1 = CircularQuantity(4090, 4096)\ne2 = CircularQuantity(10, 4096)\ndelta = e1.shortest_distance_to(e2)\n# Result: 20 counts</code></pre> </div> </div> </div> ","title":"The General Pattern"},{"content":"<div class='slide'> <h1>The Mathematical Insight</h1> <div class='info-box'> <h3>Why Does This Work?</h3> <div class='visual-demo'> <svg width='600' height='150' viewBox='0 0 600 150'> <!-- Line with endpoints --> <g transform='translate(100, 75)'> <line x1='-60' y1='0' x2='60' y2='0' stroke='#333' stroke-width='3'/> <circle cx='-60' cy='0' r='6' fill='#FF5722'/> <circle cx='60' cy='0' r='6' fill='#FF5722'/> <text x='0' y='30' text-anchor='middle' font-size='14' fill='#FFC107'>Line has endpoints</text> </g> <!-- vs --> <text x='300' y='80' text-anchor='middle' font-size='20' fill='#FFC107'>vs</text> <!-- Circle --> <g transform='translate(500, 40)'> <circle cx='0' cy='0' r='50' fill='none' stroke='#333' stroke-width='3'/> <text x='0' y='70' text-anchor='middle' font-size='14' fill='#FFC107'>Circle has none!</text> </g> </svg> </div> <p class='text-center'>A circle (S¹) is topologically different from a line segment. Linear math breaks at the wraparound point.</p> </div> <div class='two-column-equal'> <div class='card'> <h3>🌐 The Circle Problem</h3> <ul> <li><strong>Circles have no 'beginning' or 'end'</strong></li> <li>359° and 1° are neighbors</li> <li>But arithmetic says 359 - 1 = 358 🤦</li> <li>→ Solution: Use 2D vectors instead!</li> </ul> </div> <div class='card'> <h3>🔄 The Wrapping Function</h3> <svg width='300' height='120' viewBox='0 0 300 120'> <path d='M 20 80 Q 70 20, 120 80 T 220 80 T 280 80' stroke='#2196F3' stroke-width='3' fill='none'/> <text x='50' y='60' text-anchor='middle' font-size='12' fill='#FFC107'>0°</text> <text x='120' y='60' text-anchor='middle' font-size='12' fill='#FFC107'>360°</text> <text x='190' y='60' text-anchor='middle' font-size='12' fill='#FFC107'>720°</text> <text x='260' y='60' text-anchor='middle' font-size='12' fill='#FFC107'>1080°</text> </svg> <p>Angles wrap around: 370° = 10°, 730° = 10°, etc. The infinite line wraps onto the finite circle.</p> </div> </div> <div class='success-box'> <h3>🔑 The Universal Pattern</h3> <div class='process-flow'> <div class='process-step'> <h4>Problem Space</h4> <p>Non-linear manifold</p> <small>(circle, sphere, torus)</small> </div> <div class='process-step'> <h4>Embedding</h4> <p>Lift to linear space</p> <small>(ℝ², ℝ³, ℂ)</small> </div> <div class='process-step'> <h4>Computation</h4> <p>Do linear algebra</p> <small>(add, average, interpolate)</small> </div> <div class='process-step'> <h4>Projection</h4> <p>Map back to manifold</p> <small>(atan2, normalize)</small> </div> </div> </div> <div class='two-column'> <div class='warning-box'> <h3>🎯 Where Else This Appears</h3> <ul> <li><strong>Quaternions:</strong> 3D rotations in 4D space</li> <li><strong>Complex Numbers:</strong> 2D rotations in ℂ</li> <li><strong>Fourier Transform:</strong> Signals on unit circle</li> <li><strong>Neural Networks:</strong> Learned embeddings</li> </ul> </div> <div class='highlight-box'> <h3>💭 Mathematical Insight</h3> <blockquote style='font-style: italic; margin: 10px 0;'> 'The introduction of numbers as coordinates is an act of violence.' <br><cite style='font-size: 14px;'>— Hermann Weyl</cite> </blockquote> <p><strong>But sometimes, the right coordinates make the violence worthwhile!</strong></p> </div> </div> </div> ","title":"The Mathematical Insight"},{"content":"<div class='slide'> <h1>Key Takeaways</h1> <div class='main-takeaway'> <h2>🎯 The Golden Rule</h2> <div class='golden-rule'> <p>When you see a quantity that wraps around,</p> <p><strong>ask: 'Can I embed this on a circle?'</strong></p> </div> </div> <div class='practical-steps'> <h3>Your Debugging Checklist</h3> <div class='checklist'> <div class='check-item'> <span class='checkbox'>✓</span> <div> <h4>Spot the Wraparound</h4> <p>Does your value jump discontinuously? (359° → 0°, 11:59 PM → 12:00 AM)</p> </div> </div> <div class='check-item'> <span class='checkbox'>✓</span> <div> <h4>Identify the Period</h4> <p>What's the cycle length? (360° for angles, 24 hours for time, 7 for weekdays)</p> </div> </div> <div class='check-item'> <span class='checkbox'>✓</span> <div> <h4>Choose Your Embedding</h4> <p>Usually: <code style='display: inline-block;'>(cos(<span style='display: inline-block; vertical-align: middle;'><span style='display: block; text-align: center; border-bottom: 1px solid;'>2πx</span><span style='display: block; text-align: center;'>T</span></span>), sin(<span style='display: inline-block; vertical-align: middle;'><span style='display: block; text-align: center; border-bottom: 1px solid;'>2πx</span><span style='display: block; text-align: center;'>T</span></span>))</code> where <code>T</code> is the period</p> </div> </div> <div class='check-item'> <span class='checkbox'>✓</span> <div> <h4>Work in Vector Space</h4> <p>Do all math on the vectors, not the raw values</p> </div> </div> <div class='check-item'> <span class='checkbox'>✓</span> <div> <h4>Project Back When Needed</h4> <p>Use <code>atan2(y, x)</code> to recover the original quantity</p> </div> </div> </div> </div> <div class='libraries-section'> <h3>Don't Reinvent: Use Libraries!</h3> <div class='library-grid'> <div class='library'> <h4>Python</h4> <ul> <li><code>scipy.stats.circmean</code></li> <li><code>astropy.coordinates</code></li> <li><code>pyquaternion</code></li> </ul> </div> <div class='library'> <h4>JavaScript</h4> <ul> <li><code>d3-interpolate</code></li> <li><code>three.js Quaternion</code></li> <li><code>tinycolor2</code></li> </ul> </div> <div class='library'> <h4>C++</h4> <ul> <li><code>Eigen::AngleAxis</code></li> <li><code>boost::geometry</code></li> <li><code>tf2</code> (ROS)</li> </ul> </div> <div class='library'> <h4>MATLAB</h4> <ul> <li><code>circstat toolbox</code></li> <li><code>Aerospace Toolbox</code></li> <li><code>angle()</code>, <code>unwrap()</code></li> </ul> </div> </div> </div> <div class='red-flags'> <h3>🚩 Red Flags in Your Code</h3> <div class='flag-list'> <div class='flag'> <code>if (angle > 180) angle -= 360;</code> <span>→ Use circular math instead</span> </div> <div class='flag'> <code>if (crossed_midnight) /* special case */</code> <span>→ Embed on 24-hour circle</span> </div> <div class='flag'> <code>while (phase > π) phase -= 2π;</code> <span>→ Work with complex exponentials</span> </div> <div class='flag'> <code>// TODO: handle wraparound</code> <span>→ Today's the day!</span> </div> </div> </div> <div class='success-story'> <div class='story-content'> <h3>🎉 Success Story</h3> <p>'After this talk, I fixed a 3-year-old GPS bearing bug in 5 lines of code. The robot finally drives in straight lines!'</p> <cite>— Future You</cite> </div> </div> </div> ","title":"Key Takeaways"},{"content":"<div class='slide'> <h1>Interactive Demo</h1> <div class='demo-container'> <div class='demo-section'> <h3>🎮 Try It Yourself: Angle Averaging</h3> <div class='angle-inputs'> <label> Angle 1: <input type='range' id='angle1' min='0' max='359' value='350'> <span id='angle1-display'>350°</span> </label> <label> Angle 2: <input type='range' id='angle2' min='0' max='359' value='10'> <span id='angle2-display'>10°</span> </label> </div> <div class='demo-visual'> <svg width='400' height='400' viewBox='0 0 400 400' id='demo-svg'> <!-- Circle --> <circle cx='200' cy='200' r='150' fill='none' stroke='#333' stroke-width='2'/> <!-- Compass labels --> <text x='200' y='30' text-anchor='middle' font-size='16' font-weight='bold' fill='#FFC107'>0°</text> <text x='370' y='205' text-anchor='middle' font-size='16' font-weight='bold' fill='#FFC107'>90°</text> <text x='200' y='380' text-anchor='middle' font-size='16' font-weight='bold' fill='#FFC107'>180°</text> <text x='30' y='205' text-anchor='middle' font-size='16' font-weight='bold' fill='#FFC107'>270°</text> <!-- Angle 1 line --> <line id='angle1-line' x1='200' y1='200' x2='200' y2='50' stroke='#2196F3' stroke-width='4'/> <circle id='angle1-point' cx='200' cy='50' r='8' fill='#2196F3'/> <!-- Angle 2 line --> <line id='angle2-line' x1='200' y1='200' x2='200' y2='50' stroke='#4CAF50' stroke-width='4'/> <circle id='angle2-point' cx='200' cy='50' r='8' fill='#4CAF50'/> <!-- Average (wrong) --> <line id='avg-wrong-line' x1='200' y1='200' x2='200' y2='350' stroke='#FF5722' stroke-width='3' stroke-dasharray='5,5' opacity='0'/> <circle id='avg-wrong-point' cx='200' cy='350' r='6' fill='#FF5722' opacity='0'/> <!-- Average (correct) --> <line id='avg-correct-line' x1='200' y1='200' x2='200' y2='50' stroke='#FFC107' stroke-width='4'/> <circle id='avg-correct-point' cx='200' cy='50' r='8' fill='#FFC107'/> </svg> </div> <div class='demo-results'> <div class='result wrong-result'> <h4>❌ Linear Average</h4> <p id='wrong-result'>180°</p> </div> <div class='result correct-result'> <h4>✅ Circular Average</h4> <p id='correct-result'>0°</p> </div> </div> </div> <div class='code-section'> <h3>The Code Behind It</h3> <pre><code id=\"demo-code\">function circularAverage(a1, a2) {\n    // Convert to radians\n    const theta1 = a1 * Math.PI / 180;\n    const theta2 = a2 * Math.PI / 180;\n    \n    // Embed on unit circle\n    const v1 = [Math.cos(theta1), Math.sin(theta1)];\n    const v2 = [Math.cos(theta2), Math.sin(theta2)];\n    \n    // Average vectors\n    const avgVec = [(v1[0] + v2[0])/2, (v1[1] + v2[1])/2];\n    \n    // Convert back to angle\n    const avgTheta = Math.atan2(avgVec[1], avgVec[0]);\n    return (avgTheta * 180 / Math.PI + 360) % 360;\n}</code></pre> </div> </div> </div> ","title":"Interactive Demo"},{"content":"<div class='slide' style='display:grid; gap:12px;'> <h1>🌍 GIS Demo: Longitude Wraparound at the International Date Line</h1> <div class='info-box'> <h3>Real-World Problem: Computing Geographic Means</h3> <p>When averaging GPS coordinates near ±180° longitude (International Date Line), linear arithmetic fails spectacularly. A farm field split by the date line appears to span the entire globe!</p> </div> <div id='map' style='height:600px; border-radius:12px; overflow:hidden; border:1px solid rgba(255,255,255,.15)'></div> <div style='display:flex; gap:16px; flex-wrap:wrap; align-items:center;'> <label><input type='checkbox' id='worldCopy' checked> worldCopyJump (wrap world)</label> <label><input type='checkbox' id='noWrapTiles'> tile noWrap (stop wrapping tiles)</label> <span id='readout' style='opacity:.9; font-family: monospace;'>Circular mean: …</span> </div> <div class='success-box'> <h3>🎯 Try This: Drag the markers across the International Date Line!</h3> <p><strong>Red marker</strong> = Wrong linear mean | <strong>Green marker</strong> = Correct circular mean</p> <p>Watch how the linear mean jumps to the middle of the Atlantic while the circular mean stays put! This is the classic longitude wraparound bug.</p> </div> <div class='code-example'> <h3>Spherical Coordinate Embedding</h3> <pre><code class=\"language-python\"># For full lat/long geometry operations\ndef latlon_to_cartesian(lat, lon):\n    \"\"\"Embed (lat,lon) in R³ for linear operations\"\"\"\n    lat_rad = np.radians(lat)\n    lon_rad = np.radians(lon)\n    return np.array([\n        np.cos(lat_rad) * np.cos(lon_rad),  # x\n        np.cos(lat_rad) * np.sin(lon_rad),  # y  \n        np.sin(lat_rad)                     # z\n    ])\n\n# Geographic centroid (works across antimeridian!)\ndef geographic_centroid(lat_lon_pairs):\n    cartesian_points = [latlon_to_cartesian(lat, lon) \n                       for lat, lon in lat_lon_pairs]\n    mean_cartesian = np.mean(cartesian_points, axis=0)\n    mean_cartesian /= np.linalg.norm(mean_cartesian)  # Back to unit sphere\n    \n    # Convert back to lat/lon\n    lat = np.degrees(np.arcsin(mean_cartesian[2]))\n    lon = np.degrees(np.arctan2(mean_cartesian[1], mean_cartesian[0]))\n    return lat, lon</code></pre> </div> <div class='warning-box'> <h3>🏢 Company Applications</h3> <ul> <li><strong>Spatial Statistics:</strong> Computing true centroids for service areas</li> <li><strong>Route Optimization:</strong> Distance calculations that work globally</li> <li><strong>Geofencing:</strong> Boundary checks that don't break at meridians</li> <li><strong>Data Quality:</strong> Detecting GPS outliers using proper spherical distance</li> </ul> </div> </div> ","title":"🌍 GIS Demo: Longitude Wraparound at the International Date Line"},{"content":"<div class='slide flight-now'> <style> .flight-now { padding: 3vh 4vw; display: flex; flex-direction: column; gap: 2vh; } .flight-now h2 { text-align: center; margin-bottom: 1vh; background: linear-gradient(135deg, #ff6b6b, #4ecdc4); -webkit-background-clip: text; background-clip: text; color: transparent; } .grid { display: grid; grid-template-columns: 1fr 1.2fr; gap: 3vw; flex: 1; } .panel { background: rgba(255, 255, 255, 0.03); border-radius: 12px; padding: 2vh 2vw; border: 1px solid rgba(255, 255, 255, 0.1); } .left.panel { display: flex; flex-direction: column; gap: 1.5vh; } .left.panel h3 { margin: 0 0 1vh 0; color: #4ecdc4; font-size: 1.4em; } .row { display: flex; gap: 1vw; align-items: center; } .row input, .row button, .row select { padding: 8px 12px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; color: #c9d1d9; font-size: 14px; } .row input:focus, .row button:focus, .row select:focus { outline: none; border-color: #4ecdc4; box-shadow: 0 0 0 2px rgba(78, 205, 196, 0.2); } .row button { background: #4ecdc4; color: #0d1117; cursor: pointer; font-weight: 600; } .row button:hover { background: #3bb5a8; } label { font-weight: 600; color: #f0f6fc; font-size: 0.9em; margin-bottom: 0.5vh; display: block; } .muted { color: #7d8590; font-size: 0.85em; } .notes { padding: 1vh; background: rgba(255, 255, 255, 0.02); border-radius: 6px; border-left: 3px solid #4ecdc4; } .g { color: #3fb950; } .r { color: #f85149; } .b { color: #58a6ff; } .right.panel { display: flex; flex-direction: column; gap: 1.5vh; } #utc-timeline { background: rgba(255, 255, 255, 0.02); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); } .outputs { display: flex; flex-direction: column; gap: 1vh; } .chip { padding: 0.8vh 1.2vw; border-radius: 6px; font-weight: 600; font-size: 0.9em; display: flex; align-items: center; gap: 0.5em; } .chip.g { background: rgba(63, 185, 80, 0.15); border: 1px solid rgba(63, 185, 80, 0.3); } .chip.r { background: rgba(248, 81, 73, 0.15); border: 1px solid rgba(248, 81, 73, 0.3); } .chip.b { background: rgba(88, 166, 255, 0.15); border: 1px solid rgba(88, 166, 255, 0.3); } .local-readouts { padding: 1vh; background: rgba(255, 255, 255, 0.02); border-radius: 6px; text-align: center; font-size: 0.85em; } .dst-controls { display: none; background: rgba(255, 193, 7, 0.1); border: 1px solid rgba(255, 193, 7, 0.3); border-radius: 6px; padding: 1vh; font-size: 0.85em; } .dst-controls.show { display: block; } .ring-explainer { background: rgba(78, 205, 196, 0.1); border: 1px solid rgba(78, 205, 196, 0.3); border-radius: 8px; padding: 1.5vh 1.5vw; margin-top: 1vh; } .ring-explainer h4 { margin: 0 0 1vh 0; color: #4ecdc4; font-size: 1em; } .ring-explainer ul { margin: 0; padding-left: 1.5em; font-size: 0.9em; line-height: 1.4; } .ring-explainer li { margin-bottom: 0.3em; } </style> <h2>Flight vs Now: Timezone Ring Embedding</h2> <div class='grid'> <div class='left panel'> <h3>Times & Timezones</h3> <label>Flight ended in Sydney (Australia/Sydney)</label> <div class='row'> <input id='syd-date' type='date' value='2025-09-15'> <input id='syd-time' type='time' step='900' value='08:10'> </div> <div id='dst-controls' class='dst-controls'> <div>⚠️ <strong>DST transition detected!</strong></div> <div id='dst-message'></div> </div> <label>Compare with San Francisco (America/Los_Angeles)</label> <div class='row'> <button id='sf-now'>Use Now</button> <span id='sf-now-readout' class='muted'>Click to set current time</span> </div> <div class='row' style='margin-top: 1vh;'> <button id='dst-demo' style='background: #ff9500; font-size: 0.85em;'>DST Demo (Oct 5)</button> <span class='muted' style='font-size: 0.8em;'>Shows spring-forward gap</span> </div> <div class='notes'> Both deltas shown: <span class='g'>correct (UTC instants)</span> & <span class='r'>naive (local wall times)</span>. The naive approach fails because it ignores timezone offsets and DST transitions. </div> <div class='ring-explainer'> <h4>🔄 Ring Embedding Approach</h4> <ul> <li><strong>Instants:</strong> Linear UTC timeline → safe arithmetic</li> <li><strong>Local times:</strong> 24h circular ring → avoid midnight jumps</li> <li><strong>Naive error:</strong> Treats different timezone 'rings' as same coordinates</li> </ul> </div> </div> <div class='right panel'> <svg id='utc-timeline' viewBox='0 0 900 160' aria-label='UTC timeline'> <!-- Timeline will be drawn by JavaScript --> </svg> <div class='outputs'> <div class='chip g'>Δt (correct): <span id='dt-correct'>Calculate times first</span></div> <div class='chip r'>Δt (naive): <span id='dt-naive'>Calculate times first</span> <span class='muted'>(misleading)</span></div> <div class='chip b'>Offset difference: <span id='offset-diff'>—</span></div> </div> <div class='local-readouts muted'> <div><strong>Local readouts:</strong></div> <div id='syd-readout'>Sydney: Set date/time above</div> <div id='sf-readout'>San Francisco: Click 'Use Now'</div> </div> </div> </div> </div>","title":"Untitled Slide"},{"content":"<div class='slide'> <div class='questions-slide'> <h1>Questions?</h1> <div class='contact-info'> <div class='demo-offer'> <h3>🔬 Want to See This in Action?</h3> <p>I've got interactive demos for:</p> <ul> <li>Live angle averaging visualization</li> <li>Color interpolation comparison</li> <li>Robot heading controller simulation</li> </ul> </div> <div class='resources'> <h3>📚 Resources</h3> <ul> <li><strong>Slides:</strong> Available on internal wiki</li> <li><strong>Code Examples:</strong> Python/JS implementations</li> <li><strong>Further Reading:</strong> 'Lie Groups for Computer Vision' by Ethan Eade</li> </ul> </div> </div> <div class='challenge'> <h3>🏆 Challenge for Next Week</h3> <div class='challenge-box'> <p>Find ONE wraparound bug in your current codebase</p> <p>Try the embedding approach</p> <p>Share your results!</p> </div> </div> <div class='final-thought'> <blockquote> 'The best way to learn mathematics is to do mathematics.' <cite>— Paul Halmos</cite> </blockquote> <p>So go break some rings! 💍➡️📐</p> </div> <div class='thank-you'> <h2>Thank You!</h2> <div class='outro-visual'> <svg width='300' height='150' viewBox='0 0 300 150'> <!-- Circle with happy face --> <circle cx='150' cy='75' r='60' fill='none' stroke='#4CAF50' stroke-width='3'/> <!-- Happy eyes --> <circle cx='130' cy='60' r='5' fill='#4CAF50'/> <circle cx='170' cy='60' r='5' fill='#4CAF50'/> <!-- Happy smile --> <path d='M 120 90 Q 150 110 180 90' fill='none' stroke='#4CAF50' stroke-width='3'/> <!-- Surrounding points showing smooth embedding --> <g opacity='0.5'> <circle cx='90' cy='75' r='3' fill='#2196F3'/> <circle cx='210' cy='75' r='3' fill='#2196F3'/> <circle cx='150' cy='15' r='3' fill='#2196F3'/> <circle cx='150' cy='135' r='3' fill='#2196F3'/> <!-- Smooth curves connecting them --> <path d='M 90 75 Q 90 15, 150 15' fill='none' stroke='#2196F3' stroke-width='1' opacity='0.3'/> <path d='M 150 15 Q 210 15, 210 75' fill='none' stroke='#2196F3' stroke-width='1' opacity='0.3'/> <path d='M 210 75 Q 210 135, 150 135' fill='none' stroke='#2196F3' stroke-width='1' opacity='0.3'/> <path d='M 150 135 Q 90 135, 90 75' fill='none' stroke='#2196F3' stroke-width='1' opacity='0.3'/> </g> <text x='150' y='160' text-anchor='middle' font-size='12' fill='#666'> No more wraparound headaches! </text> </svg> </div> </div> </div> </div> ","title":"Questions?"}];

function initHueDragWheel() {
  // Get reference to the SVG element
  const svg = document.getElementById("dwSVG");
  if (!svg) {
    console.error("Could not find hue drag wheel SVG element");
    return;
  }

  // Define constants for the hue wheel
  const R = 179;  // Radius corrected to visual center of the ring
  const S = 100;  // Saturation percentage for HSL colors
  const L = 50;   // Lightness percentage for HSL colors

  const lineA = svg.querySelector("#lineA");
  const lineB = svg.querySelector("#lineB");
  const lineMid = svg.querySelector("#lineMid");
  const lineNaive = svg.querySelector("#lineNaive");
  const hA = svg.querySelector("#handleA");
  const hB = svg.querySelector("#handleB");
  const hMid = svg.querySelector("#handleMid");
  const hNaive = svg.querySelector("#handleNaive");
  const labA = svg.querySelector("#labelA");
  const labB = svg.querySelector("#labelB");
  const labMid = svg.querySelector("#labelMid");
  const labNaive = svg.querySelector("#labelNaive");
  const arc = svg.querySelector("#dwArc");

  const degA = document.getElementById("degA");
  const degB = document.getElementById("degB");
  const degMid = document.getElementById("degMid");
  const degNaive = document.getElementById("degNaive");
  const dotA = document.getElementById("dotA");
  const dotB = document.getElementById("dotB");
  const dotMid = document.getElementById("dotMid");
  const dotNaive = document.getElementById("dotNaive");
  const barCircular = document.getElementById("barCircular");
  const barNaive = document.getElementById("barNaive");

  // Helpers
  const clamp360 = (h) => ((h % 360) + 360) % 360;
  const deg2rad = (d) => (d * Math.PI) / 180;
  const rad2deg = (r) => (r * 180) / Math.PI;

  // Rotated hue wheel: red at North (0°), hue increases clockwise
  function posOnRing(h) {
    const a = deg2rad(h - 90); // Apply -90deg rotation
    return [200 + R * Math.cos(a), 200 + R * Math.sin(a)];
  }
  function hueFromPoint(x, y) {
    const a = Math.atan2(y - 200, x - 200);
    return clamp360(rad2deg(a) + 90); // Apply +90deg rotation
  }
  function shortestDelta(a, b) {
    return ((b - a + 540) % 360) - 180;
  } // [-180,180)
  function circularMid(h1, h2) {
    return clamp360(h1 + 0.5 * shortestDelta(h1, h2));
  }
  function naiveMid(h1, h2) {
    return clamp360((h1 + h2) / 2);
  }

  function setVector(elLine, elHandle, elLabel, hue, width = 7, dash = null) {
    const [x, y] = posOnRing(hue);
    elLine.setAttribute("x2", x);
    elLine.setAttribute("y2", y);
    // Color the line according to its hue
    elLine.setAttribute("stroke", `hsl(${hue}, ${S}%, ${L}%)`);
    elLine.setAttribute("stroke-width", width);
    if (dash) {
      elLine.setAttribute("stroke-dasharray", dash);
    } else {
      elLine.removeAttribute("stroke-dasharray");
    }
    elHandle.setAttribute("cx", x);
    elHandle.setAttribute("cy", y);
    // Color the handle with the same hue, slightly lighter
    elHandle.setAttribute(
      "fill",
      `hsl(${hue}, ${S}%, ${Math.min(70, L + 20)}%)`
    );
    // Position label slightly outside the handle
    const labelOffset = 18;
    const angle = deg2rad(hue - 90); // Apply rotation for label positioning
    elLabel.setAttribute("x", x + labelOffset * Math.cos(angle));
    elLabel.setAttribute("y", y + labelOffset * Math.sin(angle));
  }
  function setChip(dot, degree, hue) {
    dot.style.background = `hsl(${hue}, ${S}%, ${L}%)`;
    degree.textContent = `${Math.round(hue)}°`;
  }
  function setArc(h1, h2) {
    const dShort = shortestDelta(h1, h2);
    // Always draw the shortest arc
    const large = Math.abs(dShort) > 180 ? 1 : 0;
    const sweepFlag = dShort > 0 ? 1 : 0; // Positive delta = clockwise sweep
    const [ax, ay] = posOnRing(h1);
    const [bx, by] = posOnRing(h2);
    arc.setAttribute(
      "d",
      `M ${ax} ${ay} A ${R} ${R} 0 ${large} ${sweepFlag} ${bx} ${by}`
    );
  }
  function setBars(h1, h2) {
    const steps = 30;
    const colsCirc = [],
      colsNaive = [];
    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      const hm = clamp360(h1 + shortestDelta(h1, h2) * t);
      const hn = clamp360(h1 + (h2 - h1) * t);
      colsCirc.push(`hsl(${hm}, ${S}%, ${L}%)`);
      colsNaive.push(`hsl(${hn}, ${S}%, ${L}%)`);
    }
    barCircular.style.background = `linear-gradient(90deg, ${colsCirc.join(
      ","
    )})`;
    barNaive.style.background = `linear-gradient(90deg, ${colsNaive.join(
      ","
    )})`;
  }

  // State
  let H1 = 340, // Start with red-magenta
    H2 = 40;  // Start with orange
  function render() {
    const Hmid = circularMid(H1, H2);
    const Hnaive = naiveMid(H1, H2);
    setVector(lineA, hA, labA, H1, 7, null);
    setVector(lineB, hB, labB, H2, 7, null);
    setVector(lineMid, hMid, labMid, Hmid, 7, null);
    setVector(lineNaive, hNaive, labNaive, Hnaive, 5, "4,6");
    setChip(dotA, degA, H1);
    setChip(dotB, degB, H2);
    setChip(dotMid, degMid, Hmid);
    setChip(dotNaive, degNaive, Hnaive);
    setArc(H1, H2);
    setBars(H1, H2);
  }

  // Dragging
  function makeDraggable(handle, which) {
    let dragging = false;
    function onDown(e) {
      dragging = true;
      e.preventDefault();
      handle.setPointerCapture?.(e.pointerId);
    }
    function onMove(e) {
      if (!dragging) return;
      const r = svg.getBoundingClientRect();
      const x = e.clientX - r.left,
        y = e.clientY - r.top;
      const hue = hueFromPoint(x, y);
      if (which === "A") H1 = hue;
      else H2 = hue;
      render();
    }
    function onUp(e) {
      dragging = false;
      handle.releasePointerCapture?.(e.pointerId);
    }
    handle.addEventListener("pointerdown", onDown);
    window.addEventListener("pointermove", onMove);
    window.addEventListener("pointerup", onUp);
  }
  makeDraggable(hA, "A");
  makeDraggable(hB, "B");

  // Click on ring to set nearest handle
  svg.addEventListener("pointerdown", (e) => {
    const r = svg.getBoundingClientRect();
    const x = e.clientX - r.left,
      y = e.clientY - r.top;
    const hue = hueFromPoint(x, y);
    const dA = Math.abs(shortestDelta(hue, H1)),
      dB = Math.abs(shortestDelta(hue, H2));
    if (dA <= dB) H1 = hue;
    else H2 = hue;
    render();
  });

  render();
}


let currentSlide = 0;

function showSlide(index) {
    if (index < 0 || index >= slidesData.length) return;
    
    const slideContent = document.getElementById('slide-content');
    slideContent.innerHTML = slidesData[index].content;
    
    // Update counter
    document.getElementById('current-slide').textContent = index + 1;
    document.getElementById('total-slides').textContent = slidesData.length;
    
    // Update navigation buttons
    const prevButton = document.querySelector('.nav-button');
    const nextButton = document.querySelector('.nav-button:last-child');
    
    prevButton.disabled = index === 0;
    nextButton.disabled = index === slidesData.length - 1;
    
    // Add fade in animation
    slideContent.style.animation = 'none';
    slideContent.offsetHeight; // Trigger reflow
    slideContent.style.animation = 'fadeIn 0.5s';
    
    // Re-run any scripts in the slide
    const scripts = slideContent.querySelectorAll('script');
    scripts.forEach(script => {
        try {
            const newScript = document.createElement('script');
            if (script.src) {
                newScript.src = script.src;
            } else {
                newScript.textContent = script.textContent;
            }
            script.parentNode.replaceChild(newScript, script);
        } catch (error) {
            console.warn('Error re-executing script:', error);
            // Try alternative approach - evaluate script directly
            try {
                eval(script.textContent);
            } catch (evalError) {
                console.error('Failed to execute script:', evalError);
            }
        }
    });

    // Fire the slideLoaded event to trigger SVG enhancement pipeline
    window.dispatchEvent(new Event('slideLoaded'));

    // Initialize interactive demos if present
    // Check for hue drag wheel (slide 06)
    if (document.getElementById('dwSVG') && typeof initHueDragWheel === 'function') {
        console.log('🎨 Initializing hue drag wheel for slide', index + 1);
        initHueDragWheel();
    }

    // Check for vector calculator
    if (document.getElementById('vector-demo') && typeof initVectorCalculator === 'function') {
        console.log('📐 Initializing vector calculator for slide', index + 1);
        initVectorCalculator();
    }

    // Check for timeseries analyzer
    if (document.getElementById('timeseries-demo') && typeof initTimeseriesAnalyzer === 'function') {
        console.log('📈 Initializing timeseries analyzer for slide', index + 1);
        initTimeseriesAnalyzer();
    }

    currentSlide = index;
}

function nextSlide() {
    if (currentSlide < slidesData.length - 1) {
        currentSlide++;
        showSlide(currentSlide);
    }
}

function previousSlide() {
    if (currentSlide > 0) {
        currentSlide--;
        showSlide(currentSlide);
    }
}

function goToSlide(index) {
    if (index >= 0 && index < slidesData.length) {
        currentSlide = index;
        showSlide(currentSlide);
    }
}

// Keyboard navigation
document.addEventListener('keydown', function(event) {
    if (event.key === 'ArrowRight' || event.key === ' ') {
        event.preventDefault();
        nextSlide();
    } else if (event.key === 'ArrowLeft') {
        event.preventDefault();
        previousSlide();
    } else if (event.key >= '1' && event.key <= '9') {
        const slideNum = parseInt(event.key) - 1;
        if (slideNum < slidesData.length) {
            goToSlide(slideNum);
        }
    } else if (event.key === 'Home') {
        goToSlide(0);
    } else if (event.key === 'End') {
        goToSlide(slidesData.length - 1);
    }
});

// Initialize on first load
document.addEventListener('DOMContentLoaded', function() {
    showSlide(0);
});

    </script>
</body>
</html>
