<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stop Fighting Wraparound: Embed Your Rings!</title>
    <style>
:root {
  --bg: #0b0f14;
  --card: #10161d;
  --ink: #dbe2eb;
  --muted: #9fb0c6;
  --accent: #70b5ff;
  --accent2: #9bffb0;
  --accent3: #ff7b7b;
  --warning: #ffb86c;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html,
body {
  height: 100%;
  margin: 0;
  background: radial-gradient(
    1000px 800px at 70% 10%,
    #0e1420 0%,
    var(--bg) 60%
  );
  color: var(--ink);
  font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto,
    Inter, "Helvetica Neue", Arial, sans-serif;
  line-height: 1.35;
}

.slideshow-container {
  position: relative;
  width: 100%;
  height: 100vh;
  display: grid;
  grid-template-rows: 1fr auto;
}

#slide-content {
  padding: 56px 64px;
  background: radial-gradient(
      600px 400px at 10% 5%,
      rgba(112, 181, 255, 0.06),
      transparent 50%
    ),
    radial-gradient(
      700px 500px at 90% 0%,
      rgba(155, 255, 176, 0.05),
      transparent 60%
    );
  border-radius: 12px;
  margin: 20px;
  height: calc(100vh - 80px);
  overflow-y: auto;
  animation: fadeIn 0.5s cubic-bezier(0.2, 0.8, 0.2, 1);
  border: 1px solid rgba(255, 255, 255, 0.08);
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

h1 {
  font-size: 54px;
  font-weight: 750;
  letter-spacing: -0.02em;
  line-height: 1.1;
  color: var(--ink);
  margin-bottom: 30px;
  text-align: center;
}

h2 {
  font-size: 36px;
  font-weight: 700;
  letter-spacing: -0.01em;
  line-height: 1.1;
  color: var(--ink);
  margin: 30px 0 20px 0;
  border-left: 4px solid var(--accent);
  padding-left: 20px;
}

h3 {
  font-size: 22px;
  font-weight: 650;
  color: var(--muted);
  margin: 20px 0 15px 0;
}

h4 {
  font-size: 18px;
  font-weight: 600;
  color: var(--ink);
  margin: 15px 0 10px 0;
}

p,
li {
  font-size: 20px;
  color: #c9d6e5;
  line-height: 1.5;
}

.subtitle {
  text-align: center;
  color: var(--muted);
  font-size: 22px;
  margin-bottom: 40px;
}

.two-column {
  display: grid;
  grid-template-columns: 1.1fr 1fr;
  gap: 26px;
  align-items: start;
  margin: 30px 0;
}

.two-column-equal {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 26px;
  align-items: start;
  margin: 30px 0;
}

.two-column-equal img {
  width: 100%;
  height: auto;
  object-fit: contain;
}

.three-column {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 26px;
  margin: 30px 0;
}

.card,
.highlight-box,
.success-box,
.warning-box,
.info-box {
  background: linear-gradient(
    180deg,
    rgba(255, 255, 255, 0.04),
    rgba(255, 255, 255, 0.02)
  );
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 16px;
  padding: 18px 20px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
  margin: 20px 0;
}

.highlight-box {
  border-left: 4px solid var(--accent3);
  background: linear-gradient(
    180deg,
    rgba(255, 123, 123, 0.08),
    rgba(255, 123, 123, 0.04)
  );
}

.success-box {
  border-left: 4px solid var(--accent2);
  background: linear-gradient(
    180deg,
    rgba(155, 255, 176, 0.08),
    rgba(155, 255, 176, 0.04)
  );
}

.warning-box {
  border-left: 4px solid var(--warning);
  background: linear-gradient(
    180deg,
    rgba(255, 184, 108, 0.08),
    rgba(255, 184, 108, 0.04)
  );
}

.info-box {
  border-left: 4px solid var(--accent);
  background: linear-gradient(
    180deg,
    rgba(112, 181, 255, 0.08),
    rgba(112, 181, 255, 0.04)
  );
}

ul,
ol {
  margin: 15px 0;
  padding-left: 30px;
}

ul.compact li {
  margin-bottom: 8px;
}

li {
  margin: 8px 0;
}

.metric {
  background: rgba(255, 255, 255, 0.04);
  border: 1px solid rgba(255, 255, 255, 0.07);
  padding: 16px;
  border-radius: 14px;
  margin: 10px 0;
  text-align: center;
}

.metric-value {
  font-size: 36px;
  font-weight: 800;
  color: var(--accent);
}

.metric-label {
  color: var(--muted);
  font-size: 14px;
  margin-top: 4px;
  letter-spacing: 0.06em;
  text-transform: uppercase;
}

.code-block {
  background: rgba(0, 0, 0, 0.4);
  color: var(--ink);
  padding: 20px;
  border-radius: 12px;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
    "Liberation Mono", monospace;
  font-size: 16px;
  margin: 15px 0;
  overflow-x: auto;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.navigation {
  position: fixed;
  bottom: 30px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 1000;
  display: flex;
  gap: 8px;
}

.nav-button {
  background: rgba(255, 255, 255, 0.06);
  color: var(--ink);
  border: 1px solid rgba(255, 255, 255, 0.12);
  border-radius: 10px;
  padding: 8px 12px;
  cursor: pointer;
  font-weight: 600;
  font-size: 1em;
  transition: all 0.3s;
}

.nav-button:hover {
  background: rgba(255, 255, 255, 0.12);
  transform: translateY(-2px);
}

.nav-button:disabled {
  background: rgba(255, 255, 255, 0.03);
  color: var(--muted);
  cursor: not-allowed;
  transform: none;
}

.nav-button:focus {
  outline: 2px solid var(--accent);
  outline-offset: 2px;
}

.slide-counter {
  position: fixed;
  bottom: 30px;
  right: 30px;
  background: rgba(0, 0, 0, 0.5);
  color: var(--ink);
  padding: 10px 15px;
  border-radius: 20px;
  font-size: 14px;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.status-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 20px;
  margin: 20px 0;
}

.status-item {
  background: linear-gradient(
    180deg,
    rgba(255, 255, 255, 0.04),
    rgba(255, 255, 255, 0.02)
  );
  border: 2px solid rgba(255, 255, 255, 0.08);
  border-radius: 16px;
  padding: 20px;
  text-align: center;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
}

.status-item.completed {
  border-color: var(--accent2);
  background: linear-gradient(
    180deg,
    rgba(155, 255, 176, 0.08),
    rgba(155, 255, 176, 0.04)
  );
}

.status-item.in-progress {
  border-color: var(--warning);
  background: linear-gradient(
    180deg,
    rgba(255, 184, 108, 0.08),
    rgba(255, 184, 108, 0.04)
  );
}

.status-item.critical {
  border-color: var(--accent3);
  background: linear-gradient(
    180deg,
    rgba(255, 123, 123, 0.08),
    rgba(255, 123, 123, 0.04)
  );
}

.timeline {
  position: relative;
  margin: 30px 0;
}

.timeline-item {
  margin: 20px 0;
  padding-left: 40px;
  position: relative;
}

.timeline-item::before {
  content: "";
  position: absolute;
  left: 15px;
  top: 8px;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: var(--accent);
}

.timeline-item::after {
  content: "";
  position: absolute;
  left: 20px;
  top: 20px;
  width: 2px;
  height: calc(100% + 10px);
  background: rgba(255, 255, 255, 0.1);
}

.timeline-item:last-child::after {
  display: none;
}

.process-flow {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin: 30px 0;
  flex-wrap: wrap;
}

.process-step {
  background: rgba(255, 255, 255, 0.04);
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 16px;
  padding: 20px;
  margin: 10px;
  text-align: center;
  flex: 1;
  min-width: 200px;
  position: relative;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
}

.process-step::after {
  content: "→";
  position: absolute;
  right: -25px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 2em;
  color: var(--accent);
}

.process-step:last-child::after {
  display: none;
}

.mask-example {
  display: grid;
  grid-template-columns: 1fr auto 1fr;
  gap: 20px;
  margin: 20px 0;
  align-items: center;
}

.mask-box {
  background: rgba(255, 255, 255, 0.04);
  border: 1px solid rgba(255, 255, 255, 0.08);
  padding: 20px;
  border-radius: 12px;
  text-align: center;
}

.operation {
  font-size: 2em;
  color: var(--accent);
  font-weight: bold;
}

.badge {
  padding: 3px 8px;
  border-radius: 999px;
  font-size: 12px;
  color: #0a1422;
  background: linear-gradient(90deg, var(--accent), var(--accent2));
  font-weight: 700;
  display: inline-block;
}

.mono {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
    "Liberation Mono", monospace;
  font-size: 16px;
}

.kpi {
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 16px;
}

.kpi .stat {
  text-align: center;
  padding: 16px;
  border-radius: 14px;
  background: rgba(255, 255, 255, 0.04);
  border: 1px solid rgba(255, 255, 255, 0.07);
}

.kpi .num {
  font-size: 36px;
  font-weight: 800;
  color: var(--accent);
}

.kpi .label {
  font-size: 14px;
  color: var(--muted);
  margin-top: 4px;
  letter-spacing: 0.06em;
  text-transform: uppercase;
}

/* Operation list styles for slide 4 */
.operation-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin: 15px 0;
}

.op-item {
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.06);
  border-radius: 8px;
  padding: 12px 16px;
  transition: all 0.2s ease;
}

.op-item:hover {
  background: rgba(255, 255, 255, 0.04);
  border-color: rgba(255, 255, 255, 0.12);
}

.op-item strong {
  color: var(--accent);
  font-weight: 650;
}

.op-item small {
  color: var(--muted);
  font-size: 14px;
  margin-top: 4px;
  display: block;
}

.code-example {
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 12px;
  padding: 20px;
  margin: 15px 0;
}

.formula-showcase {
  text-align: center;
  background: rgba(255, 255, 255, 0.02);
  padding: 16px;
  border-radius: 10px;
  margin: 15px 0;
  border: 1px solid rgba(255, 255, 255, 0.06);
}

.formula-showcase code {
  font-size: 18px;
  font-weight: 600;
  color: var(--accent);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
    "Liberation Mono", monospace;
}

/* Scrollbar styling for dark theme */
::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: rgba(255, 255, 255, 0.05);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.2);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.3);
}

/* Title slide specific styles */
.title-slide {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  height: 100vh;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  padding: 2em;
}

.main-title {
  font-size: 3.5em;
  margin-bottom: 0.2em;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
}

.visual-element {
  margin: 2em 0;
}

.presenter-info {
  margin-top: 2em;
  text-align: center;
}

.presenter-info p {
  margin: 0.5em 0;
  font-size: 1.2em;
}

.company-branding {
  margin: 1em 0;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.1em;
}

.ByteBard97-logo {
  font-size: 2.2em;
  font-weight: 700;
  color: #4caf50;
  letter-spacing: 0.05em;
  text-shadow: 0 2px 4px rgba(76, 175, 80, 0.3);
}

.ByteBard97-ai {
  font-size: 2.2em;
  font-weight: 300;
  color: #70b5ff;
  letter-spacing: 0.05em;
  text-shadow: 0 2px 4px rgba(112, 181, 255, 0.3);
}

.presenter-info .date {
  font-size: 2em;
  font-weight: 300;
  margin-bottom: 1em;
}

/* Common visual demo styles */
.visual-demo {
  display: flex;
  justify-content: center;
  margin: 2em 0;
}

.code-comparison {
  display: flex;
  gap: 1em;
  margin: 1em 0;
}

.clock-visual {
  margin: 2em 0;
  display: flex;
  justify-content: center;
}

/* Interactive demo styles */
.demo-container {
  display: flex;
  gap: 2em;
  align-items: flex-start;
  margin: 2em 0;
}

.demo-section {
  flex: 2;
}

.code-section {
  flex: 1;
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 12px;
  padding: 20px;
}

.angle-inputs {
  display: flex;
  flex-direction: column;
  gap: 15px;
  margin: 20px 0;
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.06);
  border-radius: 12px;
  padding: 20px;
}

.angle-inputs label {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 16px;
  color: var(--ink);
}

.angle-inputs input[type="range"] {
  flex: 1;
  margin: 0 15px;
  appearance: none;
  height: 6px;
  border-radius: 3px;
  background: rgba(255, 255, 255, 0.1);
  outline: none;
}

.angle-inputs input[type="range"]::-webkit-slider-thumb {
  appearance: none;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: var(--accent);
  cursor: pointer;
}

.angle-inputs input[type="range"]::-moz-range-thumb {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: var(--accent);
  cursor: pointer;
  border: none;
}

.angle-inputs span {
  min-width: 50px;
  font-weight: 600;
  color: var(--accent);
}

.demo-visual {
  display: flex;
  justify-content: center;
  margin: 20px 0;
  background: rgba(255, 255, 255, 0.01);
  border: 1px solid rgba(255, 255, 255, 0.06);
  border-radius: 12px;
  padding: 20px;
}

.demo-results {
  display: flex;
  gap: 20px;
  justify-content: center;
  margin: 20px 0;
}

.result {
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 12px;
  padding: 15px 20px;
  text-align: center;
  min-width: 140px;
}

.wrong-result {
  border-left: 4px solid var(--accent3);
}

.correct-result {
  border-left: 4px solid var(--accent2);
}

.result h4 {
  margin: 0 0 10px 0;
  font-size: 16px;
}

.result p {
  margin: 0;
  font-size: 24px;
  font-weight: 700;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
    "Liberation Mono", monospace;
}

.wrong-result p {
  color: var(--accent3);
}

.correct-result p {
  color: var(--accent2);
}

/* Print styles */
@media print {
  body {
    background: white;
    color: #111;
  }

  #slide-content {
    background: white;
    color: #111;
    border: none;
    box-shadow: none;
    page-break-after: always;
  }

  .navigation,
  .slide-counter {
    display: none !important;
  }

  h1,
  h2,
  h3,
  p,
  li {
    color: #111;
  }

  .card,
  .highlight-box,
  .success-box,
  .warning-box,
  .info-box,
  .status-item {
    background: #fff;
    border: 1px solid #e5e7eb;
    box-shadow: none;
    color: #111;
  }
}

/* Visual comparison layout for robot heading diagrams */
.visual-comparison {
  display: flex;
  justify-content: center;
  align-items: flex-start;
  gap: 2em;
  margin: 2em 0;
  flex-wrap: wrap;
}

.visual-comparison .approach {
  flex: 1;
  max-width: 500px;
  text-align: center;
}

.visual-comparison svg {
  margin: 0 auto;
  display: block;
}

.text-center {
  text-align: center;
}

    </style>
    
    <!-- Code syntax highlighting with Highlight.js -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    
    <!-- Leaflet CSS for GIS demo -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" 
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="">
    
    <!-- Code block styling -->
    <style>
        /* Style code blocks */
        pre code {
            border: 1px solid rgba(255,255,255,0.1) !important;
            border-radius: 12px !important;
            padding: 20px !important;
            display: block;
        }
        
        /* Maintain our colored container backgrounds */
        .bad-code, .code-example {
            background: linear-gradient(180deg, rgba(255,123,123,0.08), rgba(255,123,123,0.04)) !important;
            border-left: 4px solid var(--accent3) !important;
            border-radius: 8px !important;
            padding: 1em !important;
        }
        
        .good-code, .code-solution {
            background: linear-gradient(180deg, rgba(155,255,176,0.08), rgba(155,255,176,0.04)) !important;
            border-left: 4px solid var(--accent2) !important;
            border-radius: 8px !important;
            padding: 1em !important;
        }
        
        .implementation-example {
            background: linear-gradient(180deg, rgba(156,39,176,0.08), rgba(156,39,176,0.04)) !important;
            border-left: 4px solid #9C27B0 !important;
            border-radius: 8px !important;
            padding: 1em !important;
        }
        
        .universal-class {
            background: linear-gradient(180deg, rgba(33,150,243,0.08), rgba(33,150,243,0.04)) !important;
            border-left: 4px solid #2196F3 !important;
            border-radius: 8px !important;
            padding: 1em !important;
        }
        
        .approach-bad, .approach-good {
            background: rgba(255,255,255,0.04) !important;
            border: 1px solid rgba(255,255,255,0.08) !important;
            border-radius: 8px !important;
            padding: 1em !important;
        }
    </style>

    <!-- Math rendering with MathJax -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            options: {
                renderActions: {
                    addMenu: []  // Disable context menu for cleaner presentation
                }
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <div class="slideshow-container">
        <div id="slide-content"></div>
    </div>

    <!-- Navigation -->
    <div class="navigation">
        <button class="nav-button" onclick="previousSlide()">◀ Previous</button>
        <button class="nav-button" onclick="nextSlide()">Next ▶</button>
    </div>

    <!-- Slide Counter -->
    <div class="slide-counter">
        <span id="current-slide">1</span> / <span id="total-slides">0</span>
    </div>

    <!-- Code highlighting JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>
    
    <!-- Leaflet JavaScript for GIS demo -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" 
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    
    <!-- PixiJS for interactive math demos -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js"></script>
    <script>
        document.addEventListener("DOMContentLoaded", () => {
            hljs.highlightAll();
        });
    </script>
    
<script>
// Embedded slide data for bundled version
window.slideData = {
  "0": "<div class='slide title-slide'> <h1 class='main-title'>Stop Fighting Wraparound</h1> <h2 class='subtitle'>Embed Your Rings!</h2> <div class='visual-element'> <svg width='400' height='200' viewBox='0 0 400 200'> <!-- Circle representing wraparound --> <circle cx='100' cy='100' r='80' fill='none' stroke='#4CAF50' stroke-width='3' /> <!-- Points near wraparound --> <circle cx='170' cy='100' r='8' fill='#FF5722' /> <circle cx='30' cy='100' r='8' fill='#2196F3' /> <!-- Arrow showing 'wrong' linear distance --> <path d='M 170 100 L 30 100' stroke='#FF5722' stroke-width='2' stroke-dasharray='5,5' opacity='0.5' /> <text x='100' y='90' text-anchor='middle' fill='#FF5722' font-size='14'> 140° apart? </text> <!-- Arrow showing correct arc distance --> <path d='M 170 100 A 80 80 0 0 0 30 100' fill='none' stroke='#4CAF50' stroke-width='3' /> <text x='100' y='130' text-anchor='middle' fill='#4CAF50' font-size='14' fill='#FFC107' > 20° apart! </text> <!-- Embedding arrow --> <path d='M 220 100 L 280 100' stroke='#666' stroke-width='2' marker-end='url(#arrowhead)' /> <text x='250' y='90' text-anchor='middle' fill='#666' font-size='12' fill='#FFC107' > embed </text> <!-- 2D representation --> <g transform='translate(320, 100)'> <line x1='-50' y1='0' x2='50' y2='0' stroke='#999' stroke-width='1' /> <line x1='0' y1='-50' x2='0' y2='50' stroke='#999' stroke-width='1' /> <circle cx='40' cy='0' r='8' fill='#FF5722' /> <circle cx='-40' cy='0' r='8' fill='#2196F3' /> <text x='0' y='-60' text-anchor='middle' fill='#666' font-size='12' fill='#FFC107' > ℝ² </text> </g> <!-- Arrow marker --> <defs> <marker id='arrowhead' markerWidth='10' markerHeight='7' refX='10' refY='3.5' orient='auto' > <polygon points='0 0, 10 3.5, 0 7' fill='#666' /> </marker> </defs> </svg> </div> <div class='presenter-info'> <p>A practical guide to handling circular quantities in code</p> <p class='author'>ByteBard</p> <p class='date'>Tech Talk</p> </div> </div>",

  "1": "<div class='slide'> <h1>The Bug We've All Written</h1> <div class='highlight-box'> <h3>❌ The Naive Approach</h3> <pre><code class='language-python'>def average_angle(angle1, angle2):\n    return (angle1 + angle2) / 2  # Seems reasonable...\n# Example: Average heading between two compass readings\nheading1 = 350  # degrees\nheading2 = 10   # degrees\naverage = average_angle(heading1, heading2)\nprint(f'Average: {average}°')  # 180° - COMPLETELY WRONG!</code></pre> </div> <div class='visual-demo'> <svg width='600' height='600' viewBox='0 0 300 300'> <!-- Compass circle --> <circle cx='150' cy='150' r='120' fill='none' stroke='#333' stroke-width='2'/> <!-- Compass labels --> <text x='150' y='20' text-anchor='middle' font-size='16' font-weight='bold' fill='#FFC107'>N (0°)</text> <text x='280' y='155' text-anchor='middle' font-size='16' font-weight='bold' fill='#FFC107'>E (90°)</text> <text x='150' y='290' text-anchor='middle' font-size='16' font-weight='bold' fill='#FFC107'>S (180°)</text> <text x='20' y='155' text-anchor='middle' font-size='16' font-weight='bold' fill='#FFC107'>W (270°)</text> <!-- Heading 1: 350° --> <line x1='150' y1='150' x2='140' y2='30' stroke='#2196F3' stroke-width='4'/> <circle cx='140' cy='30' r='8' fill='#2196F3'/> <text x='110' y='20' font-size='14' fill='#FFC107'>350°</text> <!-- Heading 2: 10° --> <line x1='150' y1='150' x2='160' y2='30' stroke='#4CAF50' stroke-width='4'/> <circle cx='160' cy='30' r='8' fill='#4CAF50'/> <text x='190' y='20' font-size='14' fill='#FFC107'>10°</text> <!-- Wrong average: 180° --> <line x1='150' y1='150' x2='150' y2='270' stroke='#FF5722' stroke-width='4' stroke-dasharray='5,5'/> <circle cx='150' cy='270' r='8' fill='#FF5722'/> <text x='150' y='260' text-anchor='middle' font-size='16' fill='#FF5722' font-weight='bold'> Wrong: 180° </text> <!-- Correct average indicator --> <line x1='150' y1='150' x2='150' y2='30' stroke='#FFC107' stroke-width='3' opacity='0.7'/> <text x='220' y='60' font-size='14' fill='#ffffff' font-weight='bold'>Should be ~0°!</text> </svg> </div> <div class='warning-box'> <h3>What Went Wrong?</h3> <ul> <li>350° and 10° are <strong>20° apart</strong> on the circle</li> <li>But linear math sees them as <strong>340° apart</strong></li> <li>The average points in the <strong>opposite direction</strong>!</li> </ul> </div> </div>",

  "2": "<div class='slide'> <h1>The Midnight Bug</h1> <div class='info-box'> <h3>📅 Real Scenario: Event Duration Tracking</h3> <p>Meeting started at <strong>23:45</strong> (11:45 PM)</p> <p>Meeting ended at <strong>00:15</strong> (12:15 AM)</p> </div> <div class='code-comparison'> <div class='highlight-box'> <h4>❌ What Everyone Tries First</h4> <pre><code>start_time = 23.75  # 23:45 in decimal hours\nend_time = 0.25     # 00:15 in decimal hours\nduration = end_time - start_time\nprint(f'Duration: {duration} hours')\n# Output: -23.5 hours 🤦</code></pre> </div> <div class='warning-box'> <h4>🤔 The Hacky 'Fix'</h4> <pre><code>if end_time < start_time:\n    # Must have crossed midnight\n    duration = (24 - start_time) + end_time\nelse:\n    duration = end_time - start_time\n    \n# More special cases...\nif crossed_dst:  # Daylight savings\n    duration += 1  # or -1? 😭</code></pre> </div> </div> <div class='clock-visual'> <svg width='1200' height='500' viewBox='0 0 800 300'> <!-- Linear representation --> <g transform='translate(30, 80)'> <text x='150' y='-20' text-anchor='middle' font-size='14' font-weight='bold' fill='#FFC107'>Linear View:</text> <line x1='0' y1='20' x2='300' y2='20' stroke='#333' stroke-width='2'/> <!-- Time markers --> <line x1='0' y1='15' x2='0' y2='25' stroke='#333' stroke-width='2'/> <text x='0' y='40' text-anchor='middle' font-size='12' fill='#FFC107'>0:00</text> <line x1='150' y1='15' x2='150' y2='25' stroke='#333' stroke-width='2'/> <text x='150' y='40' text-anchor='middle' font-size='12' fill='#FFC107'>12:00</text> <line x1='300' y1='15' x2='300' y2='25' stroke='#333' stroke-width='2'/> <text x='300' y='40' text-anchor='middle' font-size='12' fill='#FFC107'>24:00</text> <!-- Start time: 23:45 (23.75/24 * 300 = 296.25) --> <circle cx='296' cy='20' r='8' fill='#2196F3'/> <text x='296' y='60' text-anchor='middle' font-size='12' fill='#FFC107'>23:45</text> <!-- End time: 00:15 (0.25/24 * 300 = 3.125) --> <circle cx='3' cy='20' r='8' fill='#4CAF50'/> <text x='3' y='60' text-anchor='middle' font-size='12' fill='#FFC107'>00:15</text> <!-- Wrong distance --> <path d='M 296 20 L 3 20' stroke='#FF5722' stroke-width='2' stroke-dasharray='5,5' opacity='0.5'/> <text x='150' y='80' text-anchor='middle' fill='#FF5722' font-size='14'>Linear: -23.5 hours!</text> </g> <!-- Circular representation --> <g transform='translate(550, 150)'> <text x='0' y='-90' text-anchor='middle' font-size='14' font-weight='bold' fill='#FFC107'>Circular View:</text> <circle cx='0' cy='0' r='70' fill='none' stroke='#333' stroke-width='2'/> <!-- Clock numbers --> <text x='0' y='-55' text-anchor='middle' font-size='12' fill='#FFC107'>12</text> <text x='55' y='5' text-anchor='middle' font-size='12' fill='#FFC107'>3</text> <text x='0' y='60' text-anchor='middle' font-size='12' fill='#FFC107'>6</text> <text x='-55' y='5' text-anchor='middle' font-size='12' fill='#FFC107'>9</text> <!-- Start: 23:45 --> <line x1='0' y1='0' x2='-10' y2='-68' stroke='#2196F3' stroke-width='3'/> <circle cx='-10' cy='-68' r='8' fill='#2196F3'/> <!-- End: 00:15 --> <line x1='0' y1='0' x2='10' y2='-68' stroke='#4CAF50' stroke-width='3'/> <circle cx='10' cy='-68' r='8' fill='#4CAF50'/> <!-- Correct arc --> <path d='M -10 -68 A 70 70 0 0 1 10 -68' fill='none' stroke='#4CAF50' stroke-width='3'/> <text x='0' y='90' text-anchor='middle' fill='#4CAF50' font-size='14' font-weight='bold'> Correct: 30 minutes! </text> </g> </svg> </div> <div class='success-box'> <h3>💡 The Key Insight</h3> <p>Time-of-day is a <strong>24-hour ring</strong>, not a line!</p> <p>Linear arithmetic breaks at the wraparound point.</p> </div> </div>",

  "3": "<div class='slide'> <h1>The Missing Math Class: Circular Operations</h1> <div class='warning-box'> <h3>🤯 What They Never Taught You</h3> <p>Circular quantities are everywhere, but traditional math classes skip the operations entirely! Here's what you can actually <strong>do</strong> once you embed them as vectors:</p> </div> <div class='two-column-equal'> <div class='card'> <h3>📊 Basic Operations</h3> <div class='operation-list'> <div class='op-item'> <strong>Addition:</strong> <code>v₁ + v₂</code><br> <small>Compose two rotations</small> </div> <div class='op-item'> <strong>Subtraction:</strong> <code>v₁ - v₂</code><br> <small>Find angular difference</small> </div> <div class='op-item'> <strong>Average:</strong> <code>mean(vectors)</code><br> <small>Circular mean (always works!)</small> </div> <div class='op-item'> <strong>Interpolation:</strong> <code>slerp(v₁, v₂, t)</code><br> <small>Smooth rotation between angles</small> </div> </div> </div> <div class='card'> <h3>🧮 Advanced Operations</h3> <div class='operation-list'> <div class='op-item'> <strong>Distance:</strong> <code>shortest_path(θ₁, θ₂)</code><br> <small>Minimal angular separation</small> </div> <div class='op-item'> <strong>Scaling:</strong> <code>scalar × vector</code><br> <small>Scale magnitude, preserve direction</small> </div> <div class='op-item'> <strong>Derivatives:</strong> <code>d/dt [cos(ωt), sin(ωt)]</code><br> <small>Angular velocity vectors</small> </div> <div class='op-item'> <strong>Integration:</strong> <code>∫ ω(t) dt</code><br> <small>Accumulate rotations over time</small> </div> </div> </div> </div> <div class='success-box'> <h3>📈 Circular Statistics (The Really Cool Stuff)</h3> <div class='code-example'> <pre><code class='language-python'># Operations that actually work on circular data!\nangles = [350°, 10°, 5°, 355°]  # Wind directions\nvectors = [to_vector(θ) for θ in angles]\n# Circular mean (not 180°!)\nmean_vector = np.mean(vectors, axis=0) \nmean_angle = from_vector(mean_vector)  # ≈ 0°\n# Circular standard deviation  \ndispersion = 1 - |mean_vector|  # How 'spread out' are they?\n# Circular correlation\ncorrelation = correlate_circular(wind_dir, wave_dir)\n# Circular regression (yes, this exists!)\nslope, intercept = circular_regression(time, wave_directions)</code></pre> </div> </div> <div class='info-box'> <h3>🎯 Why This Matters</h3> <div class='three-column'> <div> <h4>🌊 Oceanography</h4> <p>Wave directions, current flows</p> </div> <div> <h4>🧭 Navigation</h4> <p>GPS, compass bearings, flight paths</p> </div> <div> <h4>🧬 Biology</h4> <p>Circadian rhythms, animal migration</p> </div> <div> <h4>🎵 Signal Processing</h4> <p>Phase analysis, Fourier transforms</p> </div> <div> <h4>🤖 Robotics</h4> <p>Joint angles, orientation control</p> </div> <div> <h4>📊 Data Science</h4> <p>Seasonal trends, cyclic patterns</p> </div> </div> </div> <div class='highlight-box'> <h3>💡 The Big Insight</h3> <p><strong>Every operation you know from linear algebra works on circular quantities—you just need to embed them first!</strong> This is why embedding is such a powerful mathematical technique.</p> <div class='formula-showcase'> <code>Circular Quantity → Vector → Linear Operation → Vector → Circular Result</code> </div> </div> </div>",

  "4": "<div class='slide'> <h1>Circular Statistics: The Hidden Superpower</h1> <div class='warning-box'> <h3>🤯 What Statistics Class Never Taught You</h3> <p>Standard statistics breaks horribly on circular data. But vector embedding makes circular statistics <strong>trivially easy</strong>—and incredibly powerful!</p> </div> <div class='two-column-equal'> <div class='card'> <h3>📊 The Problem with Regular Stats</h3> <div class='code-example'> <pre><code class='language-python'># Wind directions (degrees)\nangles = [350, 10, 5, 355]\n# Regular mean = DISASTER\nmean = sum(angles) / len(angles)  # = 180°\n# 180° is the OPPOSITE direction! 🤦‍♂️\n# Regular standard deviation = MEANINGLESS\nstd = numpy.std(angles)  # = 187°\n# Standard deviation larger than the range!</code></pre> </div> </div> <div class='card'> <h3>✨ Vector Statistics = Magic</h3> <div class='code-example'> <pre><code class='language-python'># Convert to vectors\nvectors = [angle_to_vector(θ) for θ in angles]\n# Circular mean = WORKS!\nmean_vector = np.mean(vectors, axis=0)\nmean_angle = vector_to_angle(mean_vector)  # ≈ 0°\n# Correct direction! 🎯\n# Circular standard deviation\nR = |mean_vector|  # Mean vector length\ncircular_std = sqrt(-2 * log(R))  # ≈ 22°\n# Sensible measure of spread!</code></pre> </div> </div> </div> <div class='info-box'> <h3>🧠 The Key Insight: Mean Vector Length</h3> <div class='two-column'> <div class='visual-element'> <svg width='300' height='200' viewBox='0 0 300 200'> <!-- Tight cluster --> <g transform='translate(75, 100)'> <circle r='50' fill='none' stroke='#666' stroke-width='1' opacity='0.3'/> <!-- Data points clustered tightly --> <circle cx='45' cy='5' r='4' fill='#4CAF50'/> <circle cx='47' cy='-3' r='4' fill='#4CAF50'/> <circle cx='43' cy='3' r='4' fill='#4CAF50'/> <circle cx='46' cy='0' r='4' fill='#4CAF50'/> <!-- Strong mean vector --> <path d='M 0 0 L 40 0' stroke='#FF5722' stroke-width='4' marker-end='url(#arrow)'/> <text x='0' y='-65' text-anchor='middle' fill='#4CAF50' font-size='12'>Tight Cluster</text> <text x='0' y='75' text-anchor='middle' fill='#FF5722' font-size='11'>|R| ≈ 0.95</text> <text x='0' y='87' text-anchor='middle' fill='#666' font-size='10'>Low variance</text> </g> <!-- Spread out data --> <g transform='translate(225, 100)'> <circle r='50' fill='none' stroke='#666' stroke-width='1' opacity='0.3'/> <!-- Data points spread out --> <circle cx='45' cy='5' r='4' fill='#2196F3'/> <circle cx='-30' cy='35' r='4' fill='#2196F3'/> <circle cx='-15' cy='-45' r='4' fill='#2196F3'/> <circle cx='20' cy='-40' r='4' fill='#2196F3'/> <!-- Weak mean vector --> <path d='M 0 0 L 8 -5' stroke='#FF5722' stroke-width='4' marker-end='url(#arrow)'/> <text x='0' y='-65' text-anchor='middle' fill='#2196F3' font-size='12'>Spread Out</text> <text x='0' y='75' text-anchor='middle' fill='#FF5722' font-size='11'>|R| ≈ 0.1</text> <text x='0' y='87' text-anchor='middle' fill='#666' font-size='10'>High variance</text> </g> <defs> <marker id='arrow' markerWidth='10' markerHeight='7' refX='10' refY='3.5' orient='auto'> <polygon points='0 0, 10 3.5, 0 7' fill='#FF5722'/> </marker> </defs> </svg> </div> <div> <h4>💡 The Beautiful Truth</h4> <div class='formula-showcase'> <p><strong>Tight cluster:</strong> Mean vector is long (|R| → 1)</p> <p><strong>Spread out:</strong> Mean vector is short (|R| → 0)</p> <p><strong>Uniform circle:</strong> Mean vector ≈ 0</p> </div> <p>The length of the mean vector automatically captures how 'concentrated' your circular data is!</p> </div> </div> </div> <div class='success-box'> <h3>🔬 Advanced Circular Stats That Actually Work</h3> <div class='code-example'> <pre><code class='language-python'># Circular correlation between two angular variables\ndef circular_correlation(angles1, angles2):\n    v1 = [angle_to_vector(θ) for θ in angles1]\n    v2 = [angle_to_vector(θ) for θ in angles2]\n    # Standard correlation on the vector components\n    return pearsonr(v1, v2)\n# Circular regression (yes, this exists!)\ndef circular_regression(x, circular_y):\n    vectors_y = [angle_to_vector(θ) for θ in circular_y]\n    # Regress each component separately\n    cos_model = LinearRegression().fit(x, [v[0] for v in vectors_y])\n    sin_model = LinearRegression().fit(x, [v[1] for v in vectors_y])\n    return cos_model, sin_model\n# Watson-Williams test (circular ANOVA)\n# Test if multiple groups have the same mean direction\ndef watson_williams_test(group1_angles, group2_angles):\n    # Convert to vectors, compute mean directions, test significance\n    # (This is the circular equivalent of a t-test!)</code></pre> </div> </div> <div class='highlight-box'> <h3>🌟 Real-World Applications</h3> <div class='three-column'> <div> <h4>🧬 Biology</h4> <p><strong>Animal migration:</strong> Test if birds change direction by season</p> <p><strong>Circadian rhythms:</strong> Correlate activity with time of day</p> </div> <div> <h4>🌊 Earth Sciences</h4> <p><strong>Wind patterns:</strong> Seasonal wind direction changes</p> <p><strong>Ocean currents:</strong> Correlation with tidal cycles</p> </div> <div> <h4>🎵 Signal Processing</h4> <p><strong>Phase analysis:</strong> Correlation between signal phases</p> <p><strong>Circular convolution:</strong> Periodic signal filtering</p> </div> </div> </div> </div>",

  "5": "<div class='slide'> <h1>Discrete Calculus on Circles: Data-Driven Operations</h1> <div class='info-box'> <h3>📊 Real-World Data = Discrete Samples</h3> <p>In practice, we don't have continuous functions—we have <strong>time series data</strong> of circular quantities. How do we compute derivatives and integrals when our data wraps around?</p> </div> <div class='two-column-equal'> <div class='card'> <h3>📈 Discrete Derivatives (Angular Velocity)</h3> <div class='code-example'> <pre><code class='language-python'># WRONG: Naive difference breaks at wraparound\nangles = [358°, 359°, 1°, 2°]  # Smooth rotation\nnaive_diff = [1°, 2°, -357°]  # HUGE SPIKE! 💥\n# RIGHT: Vector space derivative\nvectors = [(cos(θ), sin(θ)) for θ in angles]\ndvdt = [(v[i+1] - v[i])/dt for i in range(len(v)-1)]\n# Angular velocity from vector derivative\nω = cross_product(v[i], dvdt[i]) / |v[i]|²\n# Result: [1°/s, 1°/s, 1°/s] ✅</code></pre> </div> </div> <div class='card'> <h3>📉 Discrete Integrals (Accumulated Rotation)</h3> <div class='code-example'> <pre><code class='language-python'># WRONG: Sum angles directly\nangular_velocities = [90°/s, 90°/s, 90°/s, 90°/s]\nnaive_sum = sum(angular_velocities) * dt  # 360°???\n# RIGHT: Accumulate in vector space\nv_accumulated = [1, 0]  # Start at 0°\nfor ω in angular_velocities:\n    # Rotate vector by angular increment\n    dθ = ω * dt\n    rotation = [[cos(dθ), -sin(dθ)],\n                [sin(dθ), cos(dθ)]]\n    v_accumulated = rotation @ v_accumulated\nfinal_angle = atan2(v_accumulated)  # Correct!</code></pre> </div> </div> </div> <div class='success-box'> <h3>🔧 Practical Applications in Data Science</h3> <div class='two-column'> <div> <h4>🌊 Wind Speed Analysis</h4> <div class='code-example'> <pre><code class='language-python'># Wind direction time series (sampled every hour)\nwind_dirs = [350°, 355°, 0°, 5°, 10°]  # North-ish\nwind_speeds = [10, 12, 15, 14, 11]  # mph\n# Compute wind vector components\nu = [-speed * sin(dir) for speed, dir in zip(wind_speeds, wind_dirs)]\nv = [-speed * cos(dir) for speed, dir in zip(wind_speeds, wind_dirs)]\n# Now can compute proper derivatives!\ndu_dt = np.gradient(u)  # Wind acceleration (east)\ndv_dt = np.gradient(v)  # Wind acceleration (north)</code></pre> </div> </div> <div> <h4>🤖 Robot Heading Tracking</h4> <div class='code-example'> <pre><code class='language-python'># IMU gives heading samples at 100Hz\nheadings = sensor.get_heading_buffer()  # [θ₁, θ₂, ..., θₙ]\ndt = 0.01  # 10ms between samples\n# Convert to unit vectors\nvectors = [(cos(h), sin(h)) for h in headings]\n# Compute angular velocity using discrete derivative\nangular_vel = []\nfor i in range(len(vectors)-1):\n    # Cross product gives rotation rate\n    ω = (vectors[i][0]*vectors[i+1][1] - \n         vectors[i][1]*vectors[i+1][0]) / dt\n    angular_vel.append(ω)\n# Smooth using windowed average (no wraparound issues!)\nsmoothed_ω = moving_average(angular_vel, window=10)</code></pre> </div> </div> </div> </div> <div class='warning-box'> <h3>⚠️ Common Pitfalls with Discrete Circular Data</h3> <div class='three-column'> <div> <h4>❌ Phase Unwrapping</h4> <p><code>unwrap([350°, 10°])</code> → <code>[350°, 370°]</code></p> <p>Creates artificial trends! Use vectors instead.</p> </div> <div> <h4>❌ Modulo Arithmetic</h4> <p><code>(θ₂ - θ₁) % 360</code></p> <p>Loses direction info. Vector difference preserves it.</p> </div> <div> <h4>❌ Averaging Raw Angles</h4> <p><code>mean([0°, 90°, 180°, 270°])</code> → <code>135°</code></p> <p>Should be undefined! Vector mean → 0.</p> </div> </div> </div> <div class='highlight-box'> <h3>🎯 The Key Pattern for Discrete Operations</h3> <div class='formula-showcase'> <div style='text-align: center; padding: 20px;'> <p style='font-size: 18px; margin: 10px 0;'> <strong>Discrete Samples</strong> → <strong>Vector Time Series</strong> → <strong>Standard Numpy Operations</strong> → <strong>Interpret Results</strong> </p> <p style='margin-top: 20px;'> <code>θ[t]</code> → <code>[cos(θ[t]), sin(θ[t])]</code> → <code>np.gradient(), np.cumsum()</code> → <code>atan2() if needed</code> </p> </div> </div> <p><strong>Bottom Line:</strong> NumPy/Pandas operations 'just work' on vector representations—no special circular functions needed!</p> </div> </div>",

  "6": "<div class='slide'> <h1>Hidden Rings Everywhere: Beyond Angles & Time</h1> <div class='warning-box'> <h3>🔍 Circular Quantities Hide in Plain Sight</h3> <p>It's not just angles, time, and colors that wrap around. Here are the sneaky cyclic variables that cause bugs when you least expect them:</p> </div> <div class='pattern-table'> <table style='width: 100%; border-collapse: collapse;'> <thead> <tr style='background: rgba(33, 150, 243, 0.1); border-bottom: 2px solid #2196F3;'> <th style='padding: 12px; text-align: left; width: 30%;'>Domain</th> <th style='padding: 12px; text-align: left; width: 35%;'>❌ Where Naive Math Fails</th> <th style='padding: 12px; text-align: left; width: 35%;'>✅ Correct Embedding</th> </tr> </thead> <tbody> <tr style='border-bottom: 1px solid #444;'> <td style='padding: 10px;'><strong>📅 Weekdays</strong><br><code>d ∈ {0..6}</code></td> <td style='padding: 10px;'>Mean of Sat(6) and Mon(1) = 3.5 (Wed)?<br><span style='color: #FF5722;'>Wrong! Should be Sunday</span></td> <td style='padding: 10px;'><code>(cos(2πd/7), sin(2πd/7))</code></td> </tr> <tr style='border-bottom: 1px solid #444; background: rgba(255, 255, 255, 0.02);'> <td style='padding: 10px;'><strong>🔧 Rotary Encoders</strong><br><code>n ∈ [0, 4096)</code></td> <td style='padding: 10px;'>4095 → 1 looks like −4094 ticks<br><span style='color: #FF5722;'>Actually just 2 ticks forward!</span></td> <td style='padding: 10px;'><code>(cos(2πn/N), sin(2πn/N))</code></td> </tr> <tr style='border-bottom: 1px solid #444;'> <td style='padding: 10px;'><strong>🌍 Longitude</strong><br><code>λ ∈ [−180°, 180°)</code></td> <td style='padding: 10px;'>Mean of 179°E and 179°W = 0°?<br><span style='color: #FF5722;'>Points are 2° apart, not at Greenwich!</span></td> <td style='padding: 10px;'>3D vectors on sphere:<br><code>(cos(lat)cos(lon), cos(lat)sin(lon), sin(lat))</code></td> </tr> <tr style='border-bottom: 1px solid #444; background: rgba(255, 255, 255, 0.02);'> <td style='padding: 10px;'><strong>📡 Signal Phase</strong><br><code>φ ∈ [−π, π)</code></td> <td style='padding: 10px;'>Phase unwrapping creates artificial jumps<br><span style='color: #FF5722;'>Destroys true periodicity</span></td> <td style='padding: 10px;'>Complex: <code>e<sup>iφ</sup> = cos(φ) + i·sin(φ)</code></td> </tr> <tr style='border-bottom: 1px solid #444;'> <td style='padding: 10px;'><strong>💍 Ring Buffers</strong><br><code>idx ∈ [0, size)</code></td> <td style='padding: 10px;'><code>tail - head</code> wrong when wrapped<br><span style='color: #FF5722;'>Buffer looks full when nearly empty!</span></td> <td style='padding: 10px;'><code>(idx + size) % size</code><br>or embed as angle</td> </tr> <tr style='border-bottom: 1px solid #444; background: rgba(255, 255, 255, 0.02);'> <td style='padding: 10px;'><strong>⚙️ Gear Teeth</strong><br><code>tooth ∈ [0, N)</code></td> <td style='padding: 10px;'>Tooth 0 and Tooth N-1 look maximally apart<br><span style='color: #FF5722;'>They're actually neighbors!</span></td> <td style='padding: 10px;'><code>(cos(2πt/N), sin(2πt/N))</code></td> </tr> <tr style='border-bottom: 1px solid #444;'> <td style='padding: 10px;'><strong>🧬 Circadian Phase</strong><br><code>t ∈ [0, 24h)</code></td> <td style='padding: 10px;'>Sleep at 23:00 and 01:00 averages to noon?<br><span style='color: #FF5722;'>Should be midnight!</span></td> <td style='padding: 10px;'><code>(cos(2πt/24), sin(2πt/24))</code></td> </tr> <tr style='border-bottom: 1px solid #444; background: rgba(255, 255, 255, 0.02);'> <td style='padding: 10px;'><strong>📊 Months of Year</strong><br><code>m ∈ {1..12}</code></td> <td style='padding: 10px;'>Dec(12) to Jan(1) = -11 months?<br><span style='color: #FF5722;'>Just 1 month forward!</span></td> <td style='padding: 10px;'><code>(cos(2πm/12), sin(2πm/12))</code></td> </tr> </tbody> </table> </div> <div class='highlight-box'> <h3>💡 The Universal Solution</h3> <div class='formula-showcase'> <p style='text-align: center; font-size: 18px; margin: 15px 0;'> <strong>For ANY cyclic quantity with period T starting at offset s:</strong> </p> <p style='text-align: center; font-size: 20px; background: rgba(76, 175, 80, 0.1); padding: 15px; border-radius: 8px;'> <code>θ = 2π(value - s)/T</code> → <code>(cos(θ), sin(θ))</code> </p> <p style='text-align: center; margin-top: 15px;'> Do all your math in vector space, then project back if needed! </p> </div> </div> <div class='info-box'> <h3>🎯 When to Suspect a Hidden Ring</h3> <div class='two-column'> <div> <h4>🚩 Red Flags in Your Data</h4> <ul> <li>Values that 'roll over' or 'wrap'</li> <li>Modulo operations in the code</li> <li>Special cases for 'crossing midnight'</li> <li>Discontinuous jumps in time series</li> <li>'Distance' that depends on direction</li> </ul> </div> <div> <h4>🐛 Classic Bug Patterns</h4> <ul> <li>Averages that are wildly wrong</li> <li>Interpolation that takes the 'long way'</li> <li>Derivatives with impossible spikes</li> <li>Sorting that puts neighbors far apart</li> <li>Clustering that splits natural groups</li> </ul> </div> </div> </div> </div>",

  "7": "<div class='slide'> <h1>When Zero Isn't Special: Arbitrary Wrap Points</h1> <div class='warning-box'> <h3>🎯 Real Hardware Doesn't Care About Zero</h3> <p>Many circular quantities in the wild wrap at arbitrary values, not nice round numbers. The math still works—you just need to normalize first!</p> </div> <div class='two-column-equal'> <div class='card'> <h3>📊 Common Non-Zero Wrap Domains</h3> <div class='example-list'> <div class='example-item'> <h4>🧭 Compass: [-180°, +180°)</h4> <p>Wraps at ±180°, not 0°/360°</p> <code>bearing ∈ [-180, 180)</code> </div> <div class='example-item'> <h4>🔧 Rotary Encoder: [1000, 5096)</h4> <p>12-bit encoder with arbitrary offset</p> <code>counts ∈ [1000, 5096)</code> </div> <div class='example-item'> <h4>📡 Phase: [-π, +π)</h4> <p>Centered around zero, not starting at it</p> <code>phase ∈ [-π, π)</code> </div> <div class='example-item'> <h4>🗓️ Fiscal Year: [Apr, Mar]</h4> <p>Wraps at March/April boundary</p> <code>month ∈ [4, 3] (mod 12)</code> </div> <div class='example-item'> <h4>🌡️ ADC Values: [512, 3584)</h4> <p>Sensor with DC offset and limited range</p> <code>adc ∈ [512, 3584)</code> </div> </div> </div> <div class='card'> <h3>✨ The Universal Transform</h3> <div class='formula-showcase' style='background: rgba(76, 175, 80, 0.1); padding: 20px; border-radius: 8px; margin: 20px 0;'> <h4>For any circular quantity:</h4> <p><code>value ∈ [min, max)</code></p> <p style='margin: 15px 0;'>↓</p> <p><strong>1. Normalize to [0, 1):</strong></p> <p><code>t = (value - min) / (max - min)</code></p> <p style='margin: 15px 0;'>↓</p> <p><strong>2. Embed on unit circle:</strong></p> <p><code>v = (cos(2πt), sin(2πt))</code></p> <p style='margin: 15px 0;'>↓</p> <p><strong>3. Do your math in ℝ²</strong></p> <p style='margin: 15px 0;'>↓</p> <p><strong>4. Project back if needed:</strong></p> <p><code>result = min + (max-min) × atan2(v.y, v.x)/(2π)</code></p> </div> </div> </div> <div class='success-box'> <h3>💻 Code Example: Averaging Compass Bearings</h3> <div class='code-example'> <pre><code class='language-python'># PROBLEM: Compass uses [-180°, +180°) not [0°, 360°)\nbearings = [170, 175, -175, -170]  # All pointing roughly south\n# WRONG: Simple average\nnaive_mean = np.mean(bearings)  # = 0° (North!) 🤦\n# RIGHT: Normalize → Embed → Average → Denormalize\ndef circular_mean(values, min_val, max_val):\n    # Step 1: Normalize to [0, 1)\n    period = max_val - min_val\n    normalized = [(v - min_val) / period for v in values]\n    \n    # Step 2: Embed on circle\n    vectors = [(np.cos(2*np.pi*t), np.sin(2*np.pi*t)) for t in normalized]\n    \n    # Step 3: Average in vector space\n    mean_vector = np.mean(vectors, axis=0)\n    \n    # Step 4: Project back to original domain\n    angle = np.atan2(mean_vector[1], mean_vector[0])\n    result = min_val + (angle / (2*np.pi)) * period\n    if result < min_val:\n        result += period\n    return result\ncorrect_mean = circular_mean(bearings, -180, 180)  # ≈ 175° South! ✅</code></pre> </div> </div> <div class='info-box'> <h3>🔧 Practical Examples</h3> <div class='three-column'> <div> <h4>🎮 Game Development</h4> <div class='code-snippet'> <pre><code># Joystick angle ∈ [-π, π]\njs_angle = atan2(js.y, js.x)\n# Don't compare directly!\n# Normalize first</code></pre> </div> </div> <div> <h4>🤖 Robotics</h4> <div class='code-snippet'> <pre><code># Encoder wraps at 8192\n# but starts at 1000\nactual_pos = 1000 + \n  (raw - 1000) % 7192</code></pre> </div> </div> <div> <h4>📊 Time Series</h4> <div class='code-snippet'> <pre><code># Fiscal quarters Q2-Q1\n# April = month 0\nfiscal_month = \n  (cal_month - 4) % 12</code></pre> </div> </div> </div> </div> <div class='highlight-box'> <h3>🎯 Key Insight</h3> <p style='font-size: 18px; text-align: center; margin: 20px 0;'> <strong>The 'zero point' is arbitrary!</strong> What matters is the <em>topology</em>—that values wrap around. </p> <p style='text-align: center;'> Always normalize to [0, 1) or [0, 2π) before embedding. Your vector math doesn't care where the original wrap point was. </p> </div> </div>",

  "8": "<div class='slide'> <h1>Real Example: Robot/Drone Heading Control</h1> <div class='problem-setup'> <h3>🤖 The Scenario</h3> <p>PID controller needs to turn robot from 350° to 10°</p> </div> <div class='visual-comparison'> <div class='approach bad-approach'> <h4>❌ Naive PID Error</h4> <svg width='500' height='500' viewBox='0 0 250 250'> <circle cx='125' cy='125' r='100' fill='none' stroke='#333' stroke-width='2'/> <!-- Current heading: 350° --> <line x1='125' y1='125' x2='115' y2='25' stroke='#2196F3' stroke-width='4'/> <circle cx='115' cy='25' r='6' fill='#2196F3'/> <text x='75' y='15' font-size='12' fill='#FFC107'>Current: 350°</text> <!-- Target heading: 10° --> <line x1='125' y1='125' x2='135' y2='25' stroke='#4CAF50' stroke-width='4'/> <circle cx='135' cy='25' r='6' fill='#4CAF50'/> <text x='175' y='15' font-size='12' fill='#FFC107'>Target: 10°</text> <!-- Wrong rotation path --> <path d='M 115 25 A 100 100 0 1 1 135 25' fill='none' stroke='#FF5722' stroke-width='3' stroke-dasharray='5,5'/> <text x='125' y='200' text-anchor='middle' font-size='14' fill='#FF5722' font-weight='bold'> Error: -340° </text> <text x='125' y='220' text-anchor='middle' font-size='12' fill='#FF5722'> Spins backward! </text> </svg> <pre><code>error = target - current\nerror = 10 - 350 = -340°\n# Robot spins almost full circle\n# the wrong way!</code></pre> </div> <div class='approach good-approach'> <h4>✅ Embedded Solution</h4> <svg width='500' height='500' viewBox='0 0 250 250'> <circle cx='125' cy='125' r='100' fill='none' stroke='#333' stroke-width='2'/> <!-- Current heading: 350° --> <line x1='125' y1='125' x2='115' y2='25' stroke='#2196F3' stroke-width='4'/> <circle cx='115' cy='25' r='6' fill='#2196F3'/> <text x='75' y='15' font-size='12' fill='#FFC107'>Current: 350°</text> <!-- Target heading: 10° --> <line x1='125' y1='125' x2='135' y2='25' stroke='#4CAF50' stroke-width='4'/> <circle cx='135' cy='25' r='6' fill='#4CAF50'/> <text x='175' y='15' font-size='12' fill='#FFC107'>Target: 10°</text> <!-- Correct rotation path --> <path d='M 115 25 A 100 100 0 0 1 135 25' fill='none' stroke='#4CAF50' stroke-width='3'/> <text x='125' y='200' text-anchor='middle' font-size='14' fill='#4CAF50' font-weight='bold'> Error: +20° </text> <text x='125' y='220' text-anchor='middle' font-size='12' fill='#4CAF50'> Efficient turn! </text> </svg> <pre><code>def heading_error(current, target):\n    c_vec = [cos(current), sin(current)]\n    t_vec = [cos(target), sin(target)]\n    return atan2(cross(c_vec, t_vec), \n                 dot(c_vec, t_vec))\n# Returns: +20° (shortest path!)</code></pre> </div> </div> <div class='implementation'> <h3>Complete PID Controller Fix</h3> <pre><code class='language-python'>class HeadingController:\n    def __init__(self, kp=1.0, ki=0.1, kd=0.05):\n        self.kp, self.ki, self.kd = kp, ki, kd\n        self.integral = 0\n        self.last_error = 0\n        \n    def compute_control(self, current_heading, target_heading, dt):\n        # Embed both headings as vectors\n        current_vec = np.array([np.cos(current_heading), np.sin(current_heading)])\n        target_vec = np.array([np.cos(target_heading), np.sin(target_heading)])\n        \n        # Compute signed angle error (always shortest path)\n        error = np.arctan2(\n            current_vec[0] * target_vec[1] - current_vec[1] * target_vec[0],\n            current_vec[0] * target_vec[0] + current_vec[1] * target_vec[1]\n        )\n        \n        # Standard PID computation (now with correct error!)\n        self.integral += error * dt\n        derivative = (error - self.last_error) / dt\n        \n        control = self.kp * error + self.ki * self.integral + self.kd * derivative\n        self.last_error = error\n        \n        return control  # Angular velocity command</code></pre> </div> <div class='impact-note'> <p>💰 <strong>Real Impact:</strong> Mars Climate Orbiter was lost due to a units/wraparound error. Cost: $327.6 million</p> </div> </div>",

  "9": "<div class='slide'> <h1>Color Interpolation (HSV Hue)</h1> <div class='color-problem'> <h3>🎨 The Problem: Fade from Red to Magenta</h3> <div class='color-display'> <div class='color-box' style='background: hsl(10, 100%, 50%);'> <span>Red<br>10°</span> </div> <div class='arrow'>→</div> <div class='color-box' style='background: hsl(350, 100%, 50%);'> <span>Magenta<br>350°</span> </div> </div> </div> <div class='approaches'> <div class='approach-bad'> <h4>❌ Linear Interpolation</h4> <div class='color-gradient bad-gradient'> <div class='color-step' style='background: hsl(10, 100%, 50%);'></div> <div class='color-step' style='background: hsl(68, 100%, 50%);'></div> <div class='color-step' style='background: hsl(126, 100%, 50%);'></div> <div class='color-step' style='background: hsl(180, 100%, 50%);'></div> <div class='color-step' style='background: hsl(238, 100%, 50%);'></div> <div class='color-step' style='background: hsl(296, 100%, 50%);'></div> <div class='color-step' style='background: hsl(350, 100%, 50%);'></div> </div> <pre><code>mid_hue = (10 + 350) / 2 = 180°  # CYAN!?\n# Goes through entire rainbow!</code></pre> </div> <div class='approach-good'> <h4>✅ Circular Interpolation</h4> <div class='color-gradient good-gradient'> <div class='color-step' style='background: hsl(10, 100%, 50%);'></div> <div class='color-step' style='background: hsl(6, 100%, 50%);'></div> <div class='color-step' style='background: hsl(2, 100%, 50%);'></div> <div class='color-step' style='background: hsl(358, 100%, 50%);'></div> <div class='color-step' style='background: hsl(354, 100%, 50%);'></div> <div class='color-step' style='background: hsl(350, 100%, 50%);'></div> </div> <pre><code>vec1 = [cos(10°), sin(10°)]\nvec2 = [cos(350°), sin(350°)]\nvec_mid = normalize((vec1 + vec2) / 2)\nmid_hue = atan2(vec_mid)  # 0° (stays red!)</code></pre> </div> </div> <div class='implementation-example'> <h3>Production-Ready Color Lerp</h3> <pre><code class='javascript'>function lerpHue(h1, h2, t) {\n    // Convert hues to radians\n    const theta1 = h1 * Math.PI / 180;\n    const theta2 = h2 * Math.PI / 180;\n    \n    // Embed on unit circle\n    const v1 = [Math.cos(theta1), Math.sin(theta1)];\n    const v2 = [Math.cos(theta2), Math.sin(theta2)];\n    \n    // Interpolate vectors\n    const vt = [\n        (1 - t) * v1[0] + t * v2[0],\n        (1 - t) * v1[1] + t * v2[1]\n    ];\n    \n    // Normalize and convert back\n    const norm = Math.sqrt(vt[0]**2 + vt[1]**2);\n    const thetaT = Math.atan2(vt[1]/norm, vt[0]/norm);\n    \n    return (thetaT * 180 / Math.PI + 360) % 360;\n}\n// CSS gradient generator\nfunction generateGradient(h1, h2, steps) {\n    const colors = [];\n    for (let i = 0; i <= steps; i++) {\n        const t = i / steps;\n        const h = lerpHue(h1, h2, t);\n        colors.push(`hsl(${h}, 100%, 50%)`);\n    }\n    return `linear-gradient(90deg, ${colors.join(', ')})`;\n}</code></pre> </div> <div class='use-cases'> <h3>Where This Matters</h3> <ul> <li>🎮 <strong>Game UI:</strong> Health bar color transitions</li> <li>📊 <strong>Data Viz:</strong> Temperature/pressure heatmaps</li> <li>🎬 <strong>Animation:</strong> Smooth color transitions</li> <li>🖼️ <strong>Image Processing:</strong> Color correction algorithms</li> </ul> </div> </div>",

  "10": "<div class='slide'> <h1>The General Pattern</h1> <div class='pattern-table'> <h3>Any Circular Quantity Can Be Embedded!</h3> <table> <thead> <tr> <th>Wraparound Quantity</th> <th>Traditional Problems</th> <th>Embedding Solution</th> <th>Benefits</th> </tr> </thead> <tbody> <tr> <td><strong>Angle</strong><br>θ ∈ [0, 2π)</td> <td>Gimbal lock, discontinuities</td> <td>(cos θ, sin θ) ∈ ℝ²</td> <td>Smooth interpolation</td> </tr> <tr> <td><strong>Time of Day</strong><br>t ∈ [0, 24)</td> <td>Midnight wraparound</td> <td>(cos 2πt/24, sin 2πt/24)</td> <td>No special cases</td> </tr> <tr> <td><strong>Day of Week</strong><br>d ∈ {0..6}</td> <td>Weekend averaging</td> <td>e^(2πid/7) or 7D one-hot</td> <td>Correct statistics</td> </tr> <tr> <td><strong>Phase</strong><br>φ ∈ [-π, π)</td> <td>Phase unwrapping</td> <td>e^(iφ) ∈ ℂ</td> <td>Natural operations</td> </tr> <tr> <td><strong>Encoder Position</strong><br>n ∈ [0, 4096)</td> <td>Rollover detection</td> <td>(cos 2πn/4096, sin 2πn/4096)</td> <td>Continuous tracking</td> </tr> </tbody> </table> </div> <div class='universal-class'> <h3>One Class to Rule Them All</h3> <pre><code class='language-python'>class CircularQuantity:\n    '''Universal handler for any quantity that wraps around'''\n    \n    def __init__(self, value, period):\n        self.period = period\n        self.value = value % period  # Normalize to [0, period)\n        \n        # THE KEY: Embed on unit circle\n        theta = 2 * np.pi * self.value / period\n        self.vec = np.array([np.cos(theta), np.sin(theta)])\n    \n    def shortest_distance_to(self, other):\n        '''Always returns shortest signed distance'''\n        angle = np.arctan2(\n            self.vec[0] * other.vec[1] - self.vec[1] * other.vec[0],\n            self.vec[0] * other.vec[0] + self.vec[1] * other.vec[1]\n        )\n        return angle * self.period / (2 * np.pi)\n    \n    def average_with(self, others):\n        '''Proper circular mean'''\n        all_vecs = [self.vec] + [o.vec for o in others]\n        mean_vec = np.mean(all_vecs, axis=0)\n        mean_vec /= np.linalg.norm(mean_vec)  # Renormalize\n        \n        angle = np.arctan2(mean_vec[1], mean_vec[0])\n        mean_value = angle * self.period / (2 * np.pi)\n        return CircularQuantity(mean_value, self.period)\n    \n    def interpolate_to(self, other, t):\n        '''Smooth interpolation along shortest path'''\n        # SLERP for perfect circular interpolation\n        dot = np.dot(self.vec, other.vec)\n        omega = np.arccos(np.clip(dot, -1, 1))\n        \n        if abs(omega) < 1e-10:  # Vectors are identical\n            return self\n        \n        vec_t = (np.sin((1-t)*omega)/np.sin(omega) * self.vec +\n                 np.sin(t*omega)/np.sin(omega) * other.vec)\n        \n        angle = np.arctan2(vec_t[1], vec_t[0])\n        value = angle * self.period / (2 * np.pi)\n        return CircularQuantity(value, self.period)</code></pre> </div> <div class='examples-grid'> <div class='example'> <h4>📐 Angles</h4> <pre><code>a1 = CircularQuantity(350, 360)\na2 = CircularQuantity(10, 360)\ndist = a1.shortest_distance_to(a2)\n# Result: 20°</code></pre> </div> <div class='example'> <h4>⏰ Time</h4> <pre><code>t1 = CircularQuantity(23.5, 24)\nt2 = CircularQuantity(0.5, 24)\navg = t1.average_with([t2])\n# Result: 0.0 (midnight)</code></pre> </div> <div class='example'> <h4>📅 Weekdays</h4> <pre><code>days = [CircularQuantity(6, 7),  # Sat\n        CircularQuantity(0, 7),  # Sun\n        CircularQuantity(1, 7)]  # Mon\navg = days[0].average_with(days[1:])\n# Result: 0 (Sunday)</code></pre> </div> <div class='example'> <h4>🔄 Encoder</h4> <pre><code>e1 = CircularQuantity(4090, 4096)\ne2 = CircularQuantity(10, 4096)\ndelta = e1.shortest_distance_to(e2)\n# Result: 20 counts</code></pre> </div> </div> </div>",

  "11": "<div class='slide'> <h1>The Mathematical Insight</h1> <div class='info-box'> <h3>Why Does This Work?</h3> <div class='visual-demo'> <svg width='600' height='150' viewBox='0 0 600 150'> <!-- Line with endpoints --> <g transform='translate(100, 75)'> <line x1='-60' y1='0' x2='60' y2='0' stroke='#333' stroke-width='3'/> <circle cx='-60' cy='0' r='6' fill='#FF5722'/> <circle cx='60' cy='0' r='6' fill='#FF5722'/> <text x='0' y='30' text-anchor='middle' font-size='14' fill='#FFC107'>Line has endpoints</text> </g> <!-- vs --> <text x='300' y='80' text-anchor='middle' font-size='20' fill='#FFC107'>vs</text> <!-- Circle --> <g transform='translate(500, 75)'> <circle cx='0' cy='0' r='50' fill='none' stroke='#333' stroke-width='3'/> <text x='0' y='80' text-anchor='middle' font-size='14' fill='#FFC107'>Circle has none!</text> </g> </svg> </div> <p class='text-center'>A circle (S¹) is topologically different from a line segment. Linear math breaks at the wraparound point.</p> </div> <div class='two-column-equal'> <div class='card'> <h3>🌐 The Circle Problem</h3> <ul> <li><strong>Circles have no 'beginning' or 'end'</strong></li> <li>359° and 1° are neighbors</li> <li>But arithmetic says 359 - 1 = 358 🤦</li> <li>→ Solution: Use 2D vectors instead!</li> </ul> </div> <div class='card'> <h3>🔄 The Wrapping Function</h3> <svg width='300' height='120' viewBox='0 0 300 120'> <path d='M 20 80 Q 70 20, 120 80 T 220 80 T 280 80' stroke='#2196F3' stroke-width='3' fill='none'/> <text x='50' y='60' text-anchor='middle' font-size='12' fill='#FFC107'>0°</text> <text x='120' y='60' text-anchor='middle' font-size='12' fill='#FFC107'>360°</text> <text x='190' y='60' text-anchor='middle' font-size='12' fill='#FFC107'>720°</text> <text x='260' y='60' text-anchor='middle' font-size='12' fill='#FFC107'>1080°</text> </svg> <p>Angles wrap around: 370° = 10°, 730° = 10°, etc. The infinite line wraps onto the finite circle.</p> </div> </div> <div class='success-box'> <h3>🔑 The Universal Pattern</h3> <div class='process-flow'> <div class='process-step'> <h4>Problem Space</h4> <p>Non-linear manifold</p> <small>(circle, sphere, torus)</small> </div> <div class='process-step'> <h4>Embedding</h4> <p>Lift to linear space</p> <small>(ℝ², ℝ³, ℂ)</small> </div> <div class='process-step'> <h4>Computation</h4> <p>Do linear algebra</p> <small>(add, average, interpolate)</small> </div> <div class='process-step'> <h4>Projection</h4> <p>Map back to manifold</p> <small>(atan2, normalize)</small> </div> </div> </div> <div class='two-column'> <div class='warning-box'> <h3>🎯 Where Else This Appears</h3> <ul> <li><strong>Quaternions:</strong> 3D rotations in 4D space</li> <li><strong>Complex Numbers:</strong> 2D rotations in ℂ</li> <li><strong>Fourier Transform:</strong> Signals on unit circle</li> <li><strong>Neural Networks:</strong> Learned embeddings</li> </ul> </div> <div class='highlight-box'> <h3>💭 Mathematical Insight</h3> <blockquote style='font-style: italic; margin: 10px 0;'> 'The introduction of numbers as coordinates is an act of violence.' <br><cite style='font-size: 14px;'>— Hermann Weyl</cite> </blockquote> <p><strong>But sometimes, the right coordinates make the violence worthwhile!</strong></p> </div> </div> </div>",

  "12": "<div class='slide'> <h1>Key Takeaways</h1> <div class='main-takeaway'> <h2>🎯 The Golden Rule</h2> <div class='golden-rule'> <p>When you see a quantity that wraps around,</p> <p><strong>ask: 'Can I embed this on a circle?'</strong></p> </div> </div> <div class='practical-steps'> <h3>Your Debugging Checklist</h3> <div class='checklist'> <div class='check-item'> <span class='checkbox'>✓</span> <div> <h4>Spot the Wraparound</h4> <p>Does your value jump discontinuously? (359° → 0°, 11:59 PM → 12:00 AM)</p> </div> </div> <div class='check-item'> <span class='checkbox'>✓</span> <div> <h4>Identify the Period</h4> <p>What's the cycle length? (360° for angles, 24 hours for time, 7 for weekdays)</p> </div> </div> <div class='check-item'> <span class='checkbox'>✓</span> <div> <h4>Choose Your Embedding</h4> <p>Usually: <code style='display: inline-block;'>(cos(<span style='display: inline-block; vertical-align: middle;'><span style='display: block; text-align: center; border-bottom: 1px solid;'>2πx</span><span style='display: block; text-align: center;'>T</span></span>), sin(<span style='display: inline-block; vertical-align: middle;'><span style='display: block; text-align: center; border-bottom: 1px solid;'>2πx</span><span style='display: block; text-align: center;'>T</span></span>))</code> where <code>T</code> is the period</p> </div> </div> <div class='check-item'> <span class='checkbox'>✓</span> <div> <h4>Work in Vector Space</h4> <p>Do all math on the vectors, not the raw values</p> </div> </div> <div class='check-item'> <span class='checkbox'>✓</span> <div> <h4>Project Back When Needed</h4> <p>Use <code>atan2(y, x)</code> to recover the original quantity</p> </div> </div> </div> </div> <div class='libraries-section'> <h3>Don't Reinvent: Use Libraries!</h3> <div class='library-grid'> <div class='library'> <h4>Python</h4> <ul> <li><code>scipy.stats.circmean</code></li> <li><code>astropy.coordinates</code></li> <li><code>pyquaternion</code></li> </ul> </div> <div class='library'> <h4>JavaScript</h4> <ul> <li><code>d3-interpolate</code></li> <li><code>three.js Quaternion</code></li> <li><code>tinycolor2</code></li> </ul> </div> <div class='library'> <h4>C++</h4> <ul> <li><code>Eigen::AngleAxis</code></li> <li><code>boost::geometry</code></li> <li><code>tf2</code> (ROS)</li> </ul> </div> <div class='library'> <h4>MATLAB</h4> <ul> <li><code>circstat toolbox</code></li> <li><code>Aerospace Toolbox</code></li> <li><code>angle()</code>, <code>unwrap()</code></li> </ul> </div> </div> </div> <div class='red-flags'> <h3>🚩 Red Flags in Your Code</h3> <div class='flag-list'> <div class='flag'> <code>if (angle > 180) angle -= 360;</code> <span>→ Use circular math instead</span> </div> <div class='flag'> <code>if (crossed_midnight) /* special case */</code> <span>→ Embed on 24-hour circle</span> </div> <div class='flag'> <code>while (phase > π) phase -= 2π;</code> <span>→ Work with complex exponentials</span> </div> <div class='flag'> <code>// TODO: handle wraparound</code> <span>→ Today's the day!</span> </div> </div> </div> <div class='success-story'> <div class='story-content'> <h3>🎉 Success Story</h3> <p>'After this talk, I fixed a 3-year-old GPS bearing bug in 5 lines of code. The robot finally drives in straight lines!'</p> <cite>— Future You</cite> </div> </div> </div>",

  "13": "<div class='slide'> <h1>Interactive Demo</h1> <div class='demo-container'> <div class='demo-section'> <h3>🎮 Try It Yourself: Angle Averaging</h3> <div class='angle-inputs'> <label> Angle 1: <input type='range' id='angle1' min='0' max='359' value='350'> <span id='angle1-display'>350°</span> </label> <label> Angle 2: <input type='range' id='angle2' min='0' max='359' value='10'> <span id='angle2-display'>10°</span> </label> </div> <div class='demo-visual'> <svg width='400' height='400' viewBox='0 0 400 400' id='demo-svg'> <!-- Circle --> <circle cx='200' cy='200' r='150' fill='none' stroke='#333' stroke-width='2'/> <!-- Compass labels --> <text x='200' y='30' text-anchor='middle' font-size='16' font-weight='bold' fill='#FFC107'>0°</text> <text x='370' y='205' text-anchor='middle' font-size='16' font-weight='bold' fill='#FFC107'>90°</text> <text x='200' y='380' text-anchor='middle' font-size='16' font-weight='bold' fill='#FFC107'>180°</text> <text x='30' y='205' text-anchor='middle' font-size='16' font-weight='bold' fill='#FFC107'>270°</text> <!-- Angle 1 line --> <line id='angle1-line' x1='200' y1='200' x2='200' y2='50' stroke='#2196F3' stroke-width='4'/> <circle id='angle1-point' cx='200' cy='50' r='8' fill='#2196F3'/> <!-- Angle 2 line --> <line id='angle2-line' x1='200' y1='200' x2='200' y2='50' stroke='#4CAF50' stroke-width='4'/> <circle id='angle2-point' cx='200' cy='50' r='8' fill='#4CAF50'/> <!-- Average (wrong) --> <line id='avg-wrong-line' x1='200' y1='200' x2='200' y2='350' stroke='#FF5722' stroke-width='3' stroke-dasharray='5,5' opacity='0'/> <circle id='avg-wrong-point' cx='200' cy='350' r='6' fill='#FF5722' opacity='0'/> <!-- Average (correct) --> <line id='avg-correct-line' x1='200' y1='200' x2='200' y2='50' stroke='#FFC107' stroke-width='4'/> <circle id='avg-correct-point' cx='200' cy='50' r='8' fill='#FFC107'/> </svg> </div> <div class='demo-results'> <div class='result wrong-result'> <h4>❌ Linear Average</h4> <p id='wrong-result'>180°</p> </div> <div class='result correct-result'> <h4>✅ Circular Average</h4> <p id='correct-result'>0°</p> </div> </div> </div> <div class='code-section'> <h3>The Code Behind It</h3> <pre><code id='demo-code'>function circularAverage(a1, a2) {\n    // Convert to radians\n    const theta1 = a1 * Math.PI / 180;\n    const theta2 = a2 * Math.PI / 180;\n    \n    // Embed on unit circle\n    const v1 = [Math.cos(theta1), Math.sin(theta1)];\n    const v2 = [Math.cos(theta2), Math.sin(theta2)];\n    \n    // Average vectors\n    const avgVec = [(v1[0] + v2[0])/2, (v1[1] + v2[1])/2];\n    \n    // Convert back to angle\n    const avgTheta = Math.atan2(avgVec[1], avgVec[0]);\n    return (avgTheta * 180 / Math.PI + 360) % 360;\n}</code></pre> </div> </div> </div>",

  "14": "<div class='slide' style='display:grid; gap:12px;'> <h1>🌍 GIS Demo: Longitude Wraparound at the International Date Line</h1> <div class='info-box'> <h3>Real-World Problem: Computing Geographic Means</h3> <p>When averaging GPS coordinates near ±180° longitude (International Date Line), linear arithmetic fails spectacularly. A farm field split by the date line appears to span the entire globe!</p> </div> <div id='map' style='height:600px; border-radius:12px; overflow:hidden; border:1px solid rgba(255,255,255,.15)'></div> <div style='display:flex; gap:16px; flex-wrap:wrap; align-items:center;'> <label><input type='checkbox' id='worldCopy' checked> worldCopyJump (wrap world)</label> <label><input type='checkbox' id='noWrapTiles'> tile noWrap (stop wrapping tiles)</label> <span id='readout' style='opacity:.9; font-family: monospace;'>Circular mean: …</span> </div> <div class='success-box'> <h3>🎯 Try This: Drag the markers across the International Date Line!</h3> <p><strong>Red marker</strong> = Wrong linear mean | <strong>Green marker</strong> = Correct circular mean</p> <p>Watch how the linear mean jumps to the middle of the Atlantic while the circular mean stays put! This is the classic longitude wraparound bug.</p> </div> <div class='code-example'> <h3>Spherical Coordinate Embedding</h3> <pre><code class='language-python'># For full lat/long geometry operations\ndef latlon_to_cartesian(lat, lon):\n    '''Embed (lat,lon) in R³ for linear operations'''\n    lat_rad = np.radians(lat)\n    lon_rad = np.radians(lon)\n    return np.array([\n        np.cos(lat_rad) * np.cos(lon_rad),  # x\n        np.cos(lat_rad) * np.sin(lon_rad),  # y  \n        np.sin(lat_rad)                     # z\n    ])\n# Geographic centroid (works across antimeridian!)\ndef geographic_centroid(lat_lon_pairs):\n    cartesian_points = [latlon_to_cartesian(lat, lon) \n                       for lat, lon in lat_lon_pairs]\n    mean_cartesian = np.mean(cartesian_points, axis=0)\n    mean_cartesian /= np.linalg.norm(mean_cartesian)  # Back to unit sphere\n    \n    # Convert back to lat/lon\n    lat = np.degrees(np.arcsin(mean_cartesian[2]))\n    lon = np.degrees(np.arctan2(mean_cartesian[1], mean_cartesian[0]))\n    return lat, lon</code></pre> </div> <div class='warning-box'> <h3>🏢 Company Applications</h3> <ul> <li><strong>Spatial Statistics:</strong> Computing true centroids for service areas</li> <li><strong>Route Optimization:</strong> Distance calculations that work globally</li> <li><strong>Geofencing:</strong> Boundary checks that don't break at meridians</li> <li><strong>Data Quality:</strong> Detecting GPS outliers using proper spherical distance</li> </ul> </div> </div>",

  "15": "<div class='slide' style='display:grid; gap:12px;'> <h1>🧮 Interactive Vector Calculator</h1> <div class='info-box'> <h3>Angle Arithmetic in Action</h3> <p>Drag the red and blue handles around the circle to see vector addition and subtraction in real-time. The background shows the atan2 field - each color represents a different angle!</p> </div> <div style='display:flex; gap:16px; flex-wrap:wrap; align-items:center; margin-bottom:12px;'> <label for='vector-operation'>Operation:</label> <select id='vector-operation' style='padding:8px; border-radius:6px; background:#2d3748; color:white; border:1px solid #4a5568;'> <option value='addition'>Vector Addition</option> <option value='subtraction'>Vector Subtraction</option> </select> </div> <div id='vector-calculator-container' style='width: 100%; height: 500px; border-radius:12px; overflow:hidden; border:1px solid rgba(255,255,255,.15);'></div> <div class='success-box'> <h3>🎯 How It Works</h3> <p><strong>Addition:</strong> Yellow vector = Red angle + Blue angle (vector rotation)</p> <p><strong>Subtraction:</strong> Pink vector = Red angle - Blue angle (angular difference)</p> <p>The colorful background shows the atan2 function - it maps every pixel's position to an angle!</p> </div> <div class='code-example'> <h3>The Math Behind It</h3> <pre><code class='language-python'># Vector addition in angle space\ndef add_angles(angle1, angle2):\n    '''Add two angles - equivalent to rotating one by the other'''\n    return (angle1 + angle2) % (2 * np.pi)\ndef subtract_angles(angle1, angle2):\n    '''Find angular difference between two angles'''\n    diff = angle1 - angle2\n    # Handle wraparound\n    if diff > np.pi:\n        diff -= 2 * np.pi\n    elif diff < -np.pi:\n        diff += 2 * np.pi\n    return diff</code></pre> </div> </div>",

  "16": "<div class='slide' style='display:grid; gap:12px;'> <h1>📈 Time Series Analyzer</h1> <div class='info-box'> <h3>Circular Statistics in Practice</h3> <p>Click anywhere to add angle measurements to your time series. See how circular averaging and derivatives work on real data sequences!</p> </div> <div style='display:flex; gap:16px; flex-wrap:wrap; align-items:center; margin-bottom:12px;'> <label for='timeseries-operation'>Analysis:</label> <select id='timeseries-operation' style='padding:8px; border-radius:6px; background:#2d3748; color:white; border:1px solid #4a5568;'> <option value='average'>Circular Mean</option> <option value='derivatives'>Angular Derivatives</option> </select> <button id='clear-points' style='padding:8px 16px; border-radius:6px; background:#e53e3e; color:white; border:none; cursor:pointer;'>Clear Points</button> </div> <div id='timeseries-analyzer-container' style='width: 100%; height: 500px; border-radius:12px; overflow:hidden; border:1px solid rgba(255,255,255,.15);'></div> <div class='success-box'> <h3>🎯 Interactive Features</h3> <p><strong>Circular Mean:</strong> Yellow vector shows the true average direction (handles wraparound!)</p> <p><strong>Derivatives:</strong> Colored vectors show angular velocity between consecutive points</p> <p><strong>Pro Tip:</strong> Try clicking points that cross the 180°/-180° boundary to see wraparound handling!</p> </div> <div class='code-example'> <h3>Circular Statistics Implementation</h3> <pre><code class='language-python'># Circular mean - the RIGHT way to average angles\ndef circular_mean(angles):\n    '''Compute mean angle using vector averaging'''\n    x = np.mean(np.cos(angles))\n    y = np.mean(np.sin(angles))\n    return np.arctan2(y, x)\n# Angular derivatives with proper wraparound\ndef angular_derivatives(angle_series):\n    '''Compute finite differences handling wraparound'''\n    diffs = np.diff(angle_series)\n    # Handle wraparound: [-π, π] → [-π, π]\n    diffs = (diffs + np.pi) % (2 * np.pi) - np.pi\n    return diffs</code></pre> </div> <div class='warning-box'> <h3>🏢 Real-World Applications</h3> <ul> <li><strong>Robotics:</strong> Averaging compass headings from multiple sensors</li> <li><strong>Computer Vision:</strong> Analyzing rotation sequences in video</li> <li><strong>Finance:</strong> Cyclical time series (daily, seasonal patterns)</li> <li><strong>Signal Processing:</strong> Phase analysis in frequency domain</li> </ul> </div> </div>",

  "17": "<div class='slide'> <div class='questions-slide'> <h1>Questions?</h1> <div class='contact-info'> <div class='demo-offer'> <h3>🔬 Want to See This in Action?</h3> <p>I've got interactive demos for:</p> <ul> <li>Live angle averaging visualization</li> <li>Color interpolation comparison</li> <li>Robot heading controller simulation</li> </ul> </div> <div class='resources'> <h3>📚 Resources</h3> <ul> <li><strong>Slides:</strong> Available on internal wiki</li> <li><strong>Code Examples:</strong> Python/JS implementations</li> <li><strong>Further Reading:</strong> 'Lie Groups for Computer Vision' by Ethan Eade</li> </ul> </div> </div> <div class='challenge'> <h3>🏆 Challenge for Next Week</h3> <div class='challenge-box'> <p>Find ONE wraparound bug in your current codebase</p> <p>Try the embedding approach</p> <p>Share your results!</p> </div> </div> <div class='final-thought'> <blockquote> 'The best way to learn mathematics is to do mathematics.' <cite>— Paul Halmos</cite> </blockquote> <p>So go break some rings! 💍➡️📐</p> </div> <div class='thank-you'> <h2>Thank You!</h2> <div class='outro-visual'> <svg width='300' height='150' viewBox='0 0 300 150'> <!-- Circle with happy face --> <circle cx='150' cy='75' r='60' fill='none' stroke='#4CAF50' stroke-width='3'/> <!-- Happy eyes --> <circle cx='130' cy='60' r='5' fill='#4CAF50'/> <circle cx='170' cy='60' r='5' fill='#4CAF50'/> <!-- Happy smile --> <path d='M 120 90 Q 150 110 180 90' fill='none' stroke='#4CAF50' stroke-width='3'/> <!-- Surrounding points showing smooth embedding --> <g opacity='0.5'> <circle cx='90' cy='75' r='3' fill='#2196F3'/> <circle cx='210' cy='75' r='3' fill='#2196F3'/> <circle cx='150' cy='15' r='3' fill='#2196F3'/> <circle cx='150' cy='135' r='3' fill='#2196F3'/> <!-- Smooth curves connecting them --> <path d='M 90 75 Q 90 15, 150 15' fill='none' stroke='#2196F3' stroke-width='1' opacity='0.3'/> <path d='M 150 15 Q 210 15, 210 75' fill='none' stroke='#2196F3' stroke-width='1' opacity='0.3'/> <path d='M 210 75 Q 210 135, 150 135' fill='none' stroke='#2196F3' stroke-width='1' opacity='0.3'/> <path d='M 150 135 Q 90 135, 90 75' fill='none' stroke='#2196F3' stroke-width='1' opacity='0.3'/> </g> <text x='150' y='160' text-anchor='middle' font-size='12' fill='#666'> No more wraparound headaches! </text> </svg> </div> </div> </div> </div>"

};

// Include the unified presentation.js code
// Slide configuration - add slide filenames here in order
const slideFiles = [
    'slides/01-title.html',
    'slides/02-the-bug.html',
    'slides/03-midnight-bug.html', 
    'slides/04-the-solution.html',
    'slides/13-circular-statistics.html',
    'slides/14-discrete-calculus.html',
    'slides/15-other-circular-quantities.html',
    'slides/16-arbitrary-wrap-points.html',
    'slides/05-robot-heading.html',
    'slides/06-color-interpolation.html',
    'slides/07-general-pattern.html',
    'slides/08-mathematical-insight.html',
    'slides/09-takeaways.html',
    'slides/11-interactive-demo.html',
    'slides/12-gis-demo.html',
    'slides/16-vector-calculator.html',
    'slides/17-timeseries-analyzer.html',
    'slides/10-questions.html'
];

let currentSlide = 0;
let slidesLoaded = false;

// Global interactive app manager
window.currentInteractiveApp = null;

// Get total number of slides (from embedded data or file list)
const totalSlides = window.slideData ? Object.keys(window.slideData).length : slideFiles.length;

// Load slide content (either from embedded data or fetch)
async function loadSlide(index) {
    if (index < 0 || index >= totalSlides) return;
    
    // Clean up any existing interactive app
    if (window.currentInteractiveApp) {
        window.currentInteractiveApp.destroy(true, { children: true, texture: true, baseTexture: true });
        window.currentInteractiveApp = null;
    }
    
    try {
        let content;
        
        // Check if we have embedded slide data (bundled version)
        if (window.slideData) {
            content = window.slideData[index.toString()];
            if (!content) {
                throw new Error(`Slide data not found for key: ${index}`);
            }
        } else {
            // Fetch individual slide files (bundle folder version)
            const response = await fetch(slideFiles[index]);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            content = await response.text();
        }
        
        document.getElementById('slide-content').innerHTML = content;
        
        // Ensure code blocks have proper language classes and highlight syntax
        const slideContent = document.getElementById('slide-content');
        
        // Fix code classes for Highlight.js compatibility
        slideContent.querySelectorAll('pre code').forEach(el => {
            const cls = el.getAttribute('class') || '';
            if (/\bpython\b/i.test(cls) && !/\blanguage-python\b/i.test(cls)) {
                el.className = (cls + ' language-python').trim();
            }
            if (/\bjavascript\b/i.test(cls) && !/\blanguage-javascript\b/i.test(cls)) {
                el.className = (cls + ' language-javascript').trim();
            }
        });

        // Initialize demos based on slide content
        // Check if this is the interactive demo slide (look for the canvas element)
        if (slideContent.querySelector('#demo-canvas')) {
            setTimeout(initInteractiveDemo, 100);
        }
        
        // Check if this is the GIS demo slide (look for the map container)
        if (slideContent.querySelector('#map')) {
            setTimeout(initGISDemo, 100);
        }
        
        // Check if this is the Vector Calculator slide
        if (slideContent.querySelector('#vector-calculator-container')) {
            setTimeout(initVectorCalculator, 100);
        }
        
        // Check if this is the Time Series Analyzer slide
        if (slideContent.querySelector('#timeseries-analyzer-container')) {
            setTimeout(initTimeSeriesAnalyzer, 100);
        }
        
        // Re-run Highlight.js on the new content
        if (window.hljs) {
            slideContent.querySelectorAll('pre code').forEach(block => {
                hljs.highlightElement(block);
            });
        }
        
        // Add fade in animation
        slideContent.style.animation = 'none';
        slideContent.offsetHeight; // Trigger reflow
        slideContent.style.animation = 'fadeIn 0.5s';
        
    } catch (error) {
        console.error('Error loading slide:', error);
        document.getElementById('slide-content').innerHTML = `
            <h1>Error Loading Slide</h1>
            <p>Could not load slide: ${slideFiles[index]}</p>
            <p>Error: ${error.message}</p>
        `;
    }
}

function updateNavigation() {
    const prevButton = document.querySelector('.nav-button');
    const nextButton = document.querySelector('.nav-button:last-child');
    
    prevButton.disabled = currentSlide === 0;
    nextButton.disabled = currentSlide === totalSlides - 1;
    
    document.getElementById('current-slide').textContent = currentSlide + 1;
    document.getElementById('total-slides').textContent = totalSlides;
}

function nextSlide() {
    if (currentSlide < totalSlides - 1) {
        currentSlide++;
        loadSlide(currentSlide);
        updateNavigation();
    }
}

function previousSlide() {
    if (currentSlide > 0) {
        currentSlide--;
        loadSlide(currentSlide);
        updateNavigation();
    }
}

// Jump to specific slide (for development/testing)
function goToSlide(index) {
    if (index >= 0 && index < totalSlides) {
        currentSlide = index;
        loadSlide(currentSlide);
        updateNavigation();
    }
}

// Keyboard navigation
document.addEventListener('keydown', function(event) {
    if (event.key === 'ArrowRight' || event.key === ' ') {
        event.preventDefault();
        nextSlide();
    } else if (event.key === 'ArrowLeft') {
        event.preventDefault();
        previousSlide();
    } else if (event.key >= '1' && event.key <= '9') {
        // Jump to slide by number key
        const slideNum = parseInt(event.key) - 1;
        if (slideNum < totalSlides) {
            goToSlide(slideNum);
        }
    } else if (event.key === 'Home') {
        goToSlide(0);
    } else if (event.key === 'End') {
        goToSlide(totalSlides - 1);
    }
});

// Initialize presentation
document.addEventListener('DOMContentLoaded', function() {
    loadSlide(0);
    updateNavigation();
    slidesLoaded = true;
    
    // Add some helpful keyboard shortcuts info
    console.log('Keyboard shortcuts:');
    console.log('→ or Space: Next slide');
    console.log('←: Previous slide'); 
    console.log('1-9: Jump to slide');
    console.log('Home: First slide');
    console.log('End: Last slide');
});

// Interactive demo functionality for slide 10
function initInteractiveDemo() {
    const angle1Input = document.getElementById('angle1');
    const angle2Input = document.getElementById('angle2');
    const angle1Display = document.getElementById('angle1-display');
    const angle2Display = document.getElementById('angle2-display');
    const wrongResult = document.getElementById('wrong-result');
    const correctResult = document.getElementById('correct-result');
    
    // Check if elements exist (safety check)
    if (!angle1Input || !angle2Input) {
        console.log('Interactive demo elements not found');
        return;
    }
    
    function updateDemo() {
        const a1 = parseInt(angle1Input.value);
        const a2 = parseInt(angle2Input.value);
        
        // Update displays
        angle1Display.textContent = a1 + '°';
        angle2Display.textContent = a2 + '°';
        
        // Calculate wrong (linear) average
        const wrongAvg = (a1 + a2) / 2;
        wrongResult.textContent = Math.round(wrongAvg) + '°';
        
        // Calculate correct (circular) average
        const theta1 = a1 * Math.PI / 180;
        const theta2 = a2 * Math.PI / 180;
        const v1 = [Math.cos(theta1), Math.sin(theta1)];
        const v2 = [Math.cos(theta2), Math.sin(theta2)];
        const avgVec = [(v1[0] + v2[0])/2, (v1[1] + v2[1])/2];
        const norm = Math.sqrt(avgVec[0]**2 + avgVec[1]**2);
        avgVec[0] /= norm; avgVec[1] /= norm;
        const correctAvg = Math.atan2(avgVec[1], avgVec[0]) * 180 / Math.PI;
        const correctAvgNormalized = (correctAvg + 360) % 360;
        correctResult.textContent = Math.round(correctAvgNormalized) + '°';
        
        // Update visual
        updateVisual(a1, a2, wrongAvg, correctAvgNormalized);
        
        // Show/hide wrong result based on how wrong it is
        const wrongness = Math.abs(wrongAvg - correctAvgNormalized);
        const adjustedWrongness = Math.min(wrongness, 360 - wrongness);
        const opacity = adjustedWrongness > 30 ? 1 : 0;
        
        const wrongLine = document.getElementById('avg-wrong-line');
        const wrongPoint = document.getElementById('avg-wrong-point');
        if (wrongLine) wrongLine.style.opacity = opacity;
        if (wrongPoint) wrongPoint.style.opacity = opacity;
    }
    
    function updateVisual(a1, a2, wrongAvg, correctAvg) {
        const cx = 200, cy = 200, r = 150;
        
        // Convert angles to positions
        function angleToPos(angle) {
            const rad = (angle - 90) * Math.PI / 180; // -90 to start from top
            return {
                x: cx + r * Math.cos(rad),
                y: cy + r * Math.sin(rad)
            };
        }
        
        const pos1 = angleToPos(a1);
        const pos2 = angleToPos(a2);
        const wrongPos = angleToPos(wrongAvg);
        const correctPos = angleToPos(correctAvg);
        
        // Update lines and points safely
        const elements = [
            { id: 'angle1-line', x2: pos1.x, y2: pos1.y },
            { id: 'angle1-point', cx: pos1.x, cy: pos1.y },
            { id: 'angle2-line', x2: pos2.x, y2: pos2.y },
            { id: 'angle2-point', cx: pos2.x, cy: pos2.y },
            { id: 'avg-wrong-line', x2: wrongPos.x, y2: wrongPos.y },
            { id: 'avg-wrong-point', cx: wrongPos.x, cy: wrongPos.y },
            { id: 'avg-correct-line', x2: correctPos.x, y2: correctPos.y },
            { id: 'avg-correct-point', cx: correctPos.x, cy: correctPos.y }
        ];
        
        elements.forEach(elem => {
            const element = document.getElementById(elem.id);
            if (element) {
                if (elem.x2 !== undefined) element.setAttribute('x2', elem.x2);
                if (elem.y2 !== undefined) element.setAttribute('y2', elem.y2);
                if (elem.cx !== undefined) element.setAttribute('cx', elem.cx);
                if (elem.cy !== undefined) element.setAttribute('cy', elem.cy);
            }
        });
    }
    
    // Set up event listeners
    angle1Input.addEventListener('input', updateDemo);
    angle2Input.addEventListener('input', updateDemo);
    
    // Initial update
    updateDemo();
    
    console.log('Interactive demo initialized');
}

// GIS Demo functionality for slide 12
function initGISDemo() {
    // Check if Leaflet is loaded
    if (typeof L === 'undefined') {
        console.log('Leaflet not loaded yet, retrying...');
        setTimeout(initGISDemo, 200);
        return;
    }
    
    // Check if map container exists
    const mapContainer = document.getElementById('map');
    if (!mapContainer) {
        console.log('Map container not found');
        return;
    }
    
    // Clear any existing map
    if (window.gisMap) {
        window.gisMap.remove();
        window.gisMap = null;
    }
    
    try {
        // International Date Line area (where the real wraparound happens)
        const DATELINE_CENTER = [0.0, 180.0]; // Equator at 180° longitude

        // Map with world copy jump disabled initially, centered on the International Date Line
        const map = L.map('map', { 
            center: DATELINE_CENTER, 
            zoom: 4, 
            worldCopyJump: false 
        });
        window.gisMap = map; // Store reference for cleanup

        // OSM tiles with attribution
        let tiles = L.tileLayer(
            'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
            { 
                maxZoom: 19, 
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors' 
            }
        ).addTo(map);
        window.gisTiles = tiles;

        // Two draggable points that straddle the International Date Line (the REAL wraparound!)
        const blueIcon = L.divIcon({
            className: 'custom-marker',
            html: '<div style="background:#2196F3; width:20px; height:20px; border-radius:50%; border:3px solid white; box-shadow:0 2px 6px rgba(0,0,0,0.3);"></div>',
            iconSize: [20, 20],
            iconAnchor: [10, 10]
        });
        const orangeIcon = L.divIcon({
            className: 'custom-marker', 
            html: '<div style="background:#FF9800; width:20px; height:20px; border-radius:50%; border:3px solid white; box-shadow:0 2px 6px rgba(0,0,0,0.3);"></div>',
            iconSize: [20, 20],
            iconAnchor: [10, 10]
        });
        
        const marker1 = L.marker([5.0, 175.0], {draggable:true, icon: blueIcon}).addTo(map).bindTooltip('+175°E', {permanent:true, direction:'right'});
        const marker2 = L.marker([15.0, 178.0], {draggable:true, icon: orangeIcon}).addTo(map).bindTooltip('+178°E', {permanent:true, direction:'left'});
        const pts = [marker1, marker2];
        window.gisMarkers = pts;
        
        console.log('Created GIS markers:', pts.length, 'markers at positions:', 
                   pts.map(m => `${m.getLatLng().lat},${m.getLatLng().lng}`));

        // Circular mean helper function
        function meanLonDeg(ds) {
            let x = 0, y = 0;
            for (const d of ds) {
                const r = d * Math.PI / 180;
                x += Math.cos(r); 
                y += Math.sin(r);
            }
            let m = Math.atan2(y, x) * 180 / Math.PI;
            if (m >= 180) m -= 360;
            if (m < -180) m += 360;
            return m;
        }

        // Result markers - RED for wrong, GREEN for correct
        const wrongMarker = L.circleMarker(DATELINE_CENTER, {
            radius: 12, 
            color: '#FF1744', 
            fillColor: '#FF5252', 
            fillOpacity: 0.9,
            weight: 3
        }).addTo(map).bindTooltip('WRONG: Linear Mean', {permanent: false, direction: 'top'});
        
        const correctMarker = L.circleMarker(DATELINE_CENTER, {
            radius: 15, 
            color: '#00C853', 
            fillColor: '#00E676', 
            fillOpacity: 0.9,
            weight: 3
        }).addTo(map).bindTooltip('CORRECT: Circular Mean', {permanent: false, direction: 'bottom'});
        const readout = document.getElementById('readout');
        
        window.gisResultMarkers = [wrongMarker, correctMarker];

        function update() {
            const lats = pts.map(m => m.getLatLng().lat);
            const lons = pts.map(m => m.getLatLng().lng);
            const latAvg = lats.reduce((a, b) => a + b, 0) / lats.length;
            const linMean = (lons[0] + lons[1]) / 2; // WRONG near 0°
            const circMean = meanLonDeg(lons);

            wrongMarker.setLatLng([latAvg, linMean]);
            correctMarker.setLatLng([latAvg, circMean]);

            // Tiny line showing crossing at 0° 
            if (window.crossLine) map.removeLayer(window.crossLine);
            window.crossLine = L.polyline([[latAvg, -0.01], [latAvg, 0.01]], {color:'#4FC3F7', weight:3}).addTo(map);

            if (readout) {
                readout.textContent = 
                    `Circular mean: ${circMean.toFixed(3)}°, Linear mean (wrong): ${((linMean + 540) % 360 - 180).toFixed(3)}°`;
            }
        }

        pts.forEach(m => m.on('drag dragend', update));
        update();

        // UI toggles
        const worldCopyCheckbox = document.getElementById('worldCopy');
        const noWrapTilesCheckbox = document.getElementById('noWrapTiles');
        
        if (worldCopyCheckbox) {
            worldCopyCheckbox.addEventListener('change', (e) => {
                map.options.worldCopyJump = !!e.target.checked;
                map.panBy([1, 0]); // nudge to apply visually
            });
        }
        
        if (noWrapTilesCheckbox) {
            noWrapTilesCheckbox.addEventListener('change', (e) => {
                const noWrap = !!e.target.checked;
                map.removeLayer(tiles);
                tiles = L.tileLayer(
                    'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
                    { 
                        maxZoom: 19, 
                        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors', 
                        noWrap 
                    }
                ).addTo(map);
                window.gisTiles = tiles;
            });
        }

        console.log('GIS demo initialized');
    } catch (error) {
        console.error('Error initializing GIS demo:', error);
    }
}

// Time Series Analyzer functionality for slide 17
function initTimeSeriesAnalyzer() {
    // Check if PIXI is loaded
    if (typeof PIXI === 'undefined') {
        console.log('PIXI not loaded yet for time series analyzer, retrying...');
        setTimeout(initTimeSeriesAnalyzer, 200);
        return;
    }
    
    const container = document.getElementById('timeseries-analyzer-container');
    if (!container) {
        console.log('Time series analyzer container not found');
        return;
    }
    
    // Clean up any existing app
    if (window.currentInteractiveApp) {
        window.currentInteractiveApp.destroy(true, { children: true, texture: true, baseTexture: true });
        window.currentInteractiveApp = null;
    }
    
    // Basic placeholder - implement time series functionality here
    container.innerHTML = '<div style="color: white; padding: 20px; text-align: center;">Time Series Analyzer - Coming Soon</div>';
    
    console.log('Time Series Analyzer initialized');
}

// Vector Calculator Interactive Demo
// Visualizes vector addition and subtraction using angle representation

// GLSL Fragment Shader for atan2 background visualization
const atan2FragmentShader = `
precision mediump float;
uniform vec2 u_resolution;

// Convert HSL to RGB
vec3 hsl2rgb(float h, float s, float l) {
    float c = (1.0 - abs(2.0 * l - 1.0)) * s;
    float x = c * (1.0 - abs(mod(h * 6.0, 2.0) - 1.0));
    float m = l - c / 2.0;
    
    vec3 rgb;
    if (h < 1.0/6.0) {
        rgb = vec3(c, x, 0.0);
    } else if (h < 2.0/6.0) {
        rgb = vec3(x, c, 0.0);
    } else if (h < 3.0/6.0) {
        rgb = vec3(0.0, c, x);
    } else if (h < 4.0/6.0) {
        rgb = vec3(0.0, x, c);
    } else if (h < 5.0/6.0) {
        rgb = vec3(x, 0.0, c);
    } else {
        rgb = vec3(c, 0.0, x);
    }
    
    return rgb + m;
}

void main() {
    vec2 centered_coord = gl_FragCoord.xy - u_resolution / 2.0;
    float angle = atan(centered_coord.y, centered_coord.x);
    
    // Map angle from [-PI, PI] to [0, 1] for hue
    float hue = (angle + 3.14159265) / (2.0 * 3.14159265);
    
    // Create radial gradient for better visualization
    float distance = length(centered_coord) / min(u_resolution.x, u_resolution.y) * 2.0;
    float lightness = 0.3 + 0.4 * (1.0 - min(distance, 1.0));
    
    vec3 color = hsl2rgb(hue, 0.8, lightness);
    gl_FragColor = vec4(color, 1.0);
}
`;

// Global state for the vector calculator
let vectorCalculatorState = {
    p1_angle: 0.0,
    p2_angle: Math.PI / 4,
    operationMode: 'addition'
};

function initVectorCalculator() {
    console.log('Initializing Vector Calculator...');
    console.log('Current state:', vectorCalculatorState);
    
    // Check if PIXI is loaded
    if (typeof PIXI === 'undefined') {
        console.log('PIXI not loaded yet, retrying...');
        setTimeout(initVectorCalculator, 200);
        return;
    }
    
    const container = document.getElementById('vector-calculator-container');
    if (!container) {
        console.log('Vector calculator container not found');
        return;
    }
    
    // Clean up any existing app
    if (window.currentInteractiveApp) {
        window.currentInteractiveApp.destroy(true, { children: true, texture: true, baseTexture: true });
        window.currentInteractiveApp = null;
    }
    
    // Create PIXI application
    const app = new PIXI.Application({
        width: container.offsetWidth,
        height: container.offsetHeight,
        backgroundColor: 0x000000,
        antialias: true
    });
    
    container.appendChild(app.view);
    window.currentInteractiveApp = app;
    
    // Create custom filter for atan2 background
    const atan2Filter = new PIXI.Filter(undefined, atan2FragmentShader, {
        u_resolution: [app.screen.width, app.screen.height]
    });
    
    // Apply background filter
    app.stage.filterArea = app.screen;
    app.stage.filters = [atan2Filter];
    
    // Create graphics objects
    const graphics = new PIXI.Graphics();
    app.stage.addChild(graphics);
    
    // Interactive state
    let isDragging = false;
    let dragTarget = null;
    
    // Make stage interactive
    app.stage.interactive = true;
    
    // Drawing function
    function draw() {
        graphics.clear();
        
        const centerX = app.screen.width / 2;
        const centerY = app.screen.height / 2;
        const radius = Math.min(centerX, centerY) * 0.7;
        
        // Draw unit circle
        graphics.lineStyle(3, 0xFFFFFF, 0.8);
        graphics.drawCircle(centerX, centerY, radius);
        
        // Calculate positions
        const p1x = centerX + Math.cos(vectorCalculatorState.p1_angle) * radius;
        const p1y = centerY + Math.sin(vectorCalculatorState.p1_angle) * radius;
        const p2x = centerX + Math.cos(vectorCalculatorState.p2_angle) * radius;
        const p2y = centerY + Math.sin(vectorCalculatorState.p2_angle) * radius;
        
        // Draw vectors with thicker lines
        graphics.lineStyle(6, 0xFF6B6B, 1.0);
        graphics.moveTo(centerX, centerY);
        graphics.lineTo(p1x, p1y);
        
        graphics.lineStyle(6, 0x4ECDC4, 1.0);
        graphics.moveTo(centerX, centerY);
        graphics.lineTo(p2x, p2y);
        
        // Draw result based on operation mode
        if (vectorCalculatorState.operationMode === 'addition') {
            const resultAngle = vectorCalculatorState.p1_angle + vectorCalculatorState.p2_angle;
            const resultX = centerX + Math.cos(resultAngle) * radius;
            const resultY = centerY + Math.sin(resultAngle) * radius;
            
            graphics.lineStyle(6, 0xFFE66D);
            graphics.moveTo(centerX, centerY);
            graphics.lineTo(resultX, resultY);
        } else {
            // Subtraction - show angle between vectors
            const angleDiff = vectorCalculatorState.p1_angle - vectorCalculatorState.p2_angle;
            const resultX = centerX + Math.cos(angleDiff) * radius;
            const resultY = centerY + Math.sin(angleDiff) * radius;
            
            graphics.lineStyle(6, 0xFF8B94);
            graphics.moveTo(centerX, centerY);
            graphics.lineTo(resultX, resultY);
        }
        
        // Draw draggable handles with white outlines for visibility
        graphics.lineStyle(3, 0xFFFFFF, 1.0);
        graphics.beginFill(0xFF6B6B, 1.0);
        graphics.drawCircle(p1x, p1y, 15);
        graphics.endFill();
        
        graphics.lineStyle(3, 0xFFFFFF, 1.0);
        graphics.beginFill(0x4ECDC4, 1.0);
        graphics.drawCircle(p2x, p2y, 15);
        graphics.endFill();
        
        // Add text labels near handles
        graphics.lineStyle(0);
        graphics.beginFill(0xFFFFFF, 0.9);
        graphics.drawCircle(p1x + 20, p1y - 20, 8);
        graphics.drawCircle(p2x + 20, p2y - 20, 8);
        graphics.endFill();
    }
    
    // Event handlers
    app.stage.on('pointerdown', (event) => {
        const pos = event.data.global;
        const centerX = app.screen.width / 2;
        const centerY = app.screen.height / 2;
        const radius = Math.min(centerX, centerY) * 0.7;
        
        const p1x = centerX + Math.cos(vectorCalculatorState.p1_angle) * radius;
        const p1y = centerY + Math.sin(vectorCalculatorState.p1_angle) * radius;
        const p2x = centerX + Math.cos(vectorCalculatorState.p2_angle) * radius;
        const p2y = centerY + Math.sin(vectorCalculatorState.p2_angle) * radius;
        
        // Check if clicking on handles (larger hit area for easier interaction)
        const dist1 = Math.sqrt((pos.x - p1x) ** 2 + (pos.y - p1y) ** 2);
        const dist2 = Math.sqrt((pos.x - p2x) ** 2 + (pos.y - p2y) ** 2);
        
        if (dist1 < 30) {
            isDragging = true;
            dragTarget = 'p1';
            console.log('Dragging red handle');
        } else if (dist2 < 30) {
            isDragging = true;
            dragTarget = 'p2';
            console.log('Dragging blue handle');
        }
    });
    
    app.stage.on('pointermove', (event) => {
        if (!isDragging) return;
        
        const pos = event.data.global;
        const centerX = app.screen.width / 2;
        const centerY = app.screen.height / 2;
        
        const angle = Math.atan2(pos.y - centerY, pos.x - centerX);
        
        if (dragTarget === 'p1') {
            vectorCalculatorState.p1_angle = angle;
        } else if (dragTarget === 'p2') {
            vectorCalculatorState.p2_angle = angle;
        }
        
        draw();
    });
    
    app.stage.on('pointerup', () => {
        isDragging = false;
        dragTarget = null;
    });
    
    // Hook up dropdown
    const dropdown = document.getElementById('vector-operation');
    if (dropdown) {
        dropdown.addEventListener('change', (e) => {
            vectorCalculatorState.operationMode = e.target.value;
            draw();
        });
    }
    
    // Initial draw
    draw();
    
    console.log('Vector Calculator initialized');
}

// Time Series Analyzer Interactive Demo
// Visualizes circular statistics and derivatives for angle sequences

// Global state for the time series analyzer
let timeSeriesState = {
    points: [],
    operationMode: 'average'
};

function initTimeSeriesAnalyzer() {
    console.log('Initializing Time Series Analyzer...');
    
    // Check if PIXI is loaded
    if (typeof PIXI === 'undefined') {
        console.log('PIXI not loaded yet, retrying...');
        setTimeout(initTimeSeriesAnalyzer, 200);
        return;
    }
    
    const container = document.getElementById('timeseries-analyzer-container');
    if (!container) {
        console.log('Time series analyzer container not found');
        return;
    }
    
    // Clean up any existing app
    if (window.currentInteractiveApp) {
        window.currentInteractiveApp.destroy(true, { children: true, texture: true, baseTexture: true });
        window.currentInteractiveApp = null;
    }
    
    // Create PIXI application
    const app = new PIXI.Application({
        width: container.offsetWidth,
        height: container.offsetHeight,
        backgroundColor: 0x000000,
        antialias: true
    });
    
    container.appendChild(app.view);
    window.currentInteractiveApp = app;
    
    // Reuse the atan2 filter from vector calculator
    const atan2Filter = new PIXI.Filter(undefined, `
        precision mediump float;
        uniform vec2 u_resolution;
        
        vec3 hsl2rgb(float h, float s, float l) {
            float c = (1.0 - abs(2.0 * l - 1.0)) * s;
            float x = c * (1.0 - abs(mod(h * 6.0, 2.0) - 1.0));
            float m = l - c / 2.0;
            
            vec3 rgb;
            if (h < 1.0/6.0) {
                rgb = vec3(c, x, 0.0);
            } else if (h < 2.0/6.0) {
                rgb = vec3(x, c, 0.0);
            } else if (h < 3.0/6.0) {
                rgb = vec3(0.0, c, x);
            } else if (h < 4.0/6.0) {
                rgb = vec3(0.0, x, c);
            } else if (h < 5.0/6.0) {
                rgb = vec3(x, 0.0, c);
            } else {
                rgb = vec3(c, 0.0, x);
            }
            
            return rgb + m;
        }
        
        void main() {
            vec2 centered_coord = gl_FragCoord.xy - u_resolution / 2.0;
            float angle = atan(centered_coord.y, centered_coord.x);
            float hue = (angle + 3.14159265) / (2.0 * 3.14159265);
            float distance = length(centered_coord) / min(u_resolution.x, u_resolution.y) * 2.0;
            float lightness = 0.2 + 0.3 * (1.0 - min(distance, 1.0));
            vec3 color = hsl2rgb(hue, 0.6, lightness);
            gl_FragColor = vec4(color, 1.0);
        }
    `, {
        u_resolution: [app.screen.width, app.screen.height]
    });
    
    // Apply background filter
    app.stage.filterArea = app.screen;
    app.stage.filters = [atan2Filter];
    
    // Create graphics objects
    const graphics = new PIXI.Graphics();
    app.stage.addChild(graphics);
    
    // Make stage interactive
    app.stage.interactive = true;
    
    // Circular mean calculation
    function calculateCircularMean(angles) {
        if (angles.length === 0) return 0;
        
        let x = 0, y = 0;
        for (const angle of angles) {
            x += Math.cos(angle);
            y += Math.sin(angle);
        }
        return Math.atan2(y, x);
    }
    
    // Calculate finite differences (derivatives)
    function calculateDerivatives(angles) {
        if (angles.length < 2) return [];
        
        const derivatives = [];
        for (let i = 1; i < angles.length; i++) {
            let diff = angles[i] - angles[i-1];
            
            // Handle angle wraparound
            if (diff > Math.PI) diff -= 2 * Math.PI;
            if (diff < -Math.PI) diff += 2 * Math.PI;
            
            derivatives.push(diff);
        }
        return derivatives;
    }
    
    // Drawing function
    function draw() {
        graphics.clear();
        
        const centerX = app.screen.width / 2;
        const centerY = app.screen.height / 2;
        const radius = Math.min(centerX, centerY) * 0.7;
        
        // Draw unit circle
        graphics.lineStyle(2, 0xFFFFFF, 0.3);
        graphics.drawCircle(centerX, centerY, radius);
        
        // Draw all clicked points
        timeSeriesState.points.forEach((point, index) => {
            const x = centerX + Math.cos(point.angle) * radius;
            const y = centerY + Math.sin(point.angle) * radius;
            
            // Draw point
            graphics.beginFill(0xFFFFFF, 0.8);
            graphics.drawCircle(x, y, 6);
            graphics.endFill();
            
            // Draw line from center
            graphics.lineStyle(2, 0xFFFFFF, 0.4);
            graphics.moveTo(centerX, centerY);
            graphics.lineTo(x, y);
            
            // Draw index number
            const text = new PIXI.Text(index.toString(), {
                fontSize: 12,
                fill: 0xFFFFFF
            });
            text.anchor.set(0.5);
            text.x = x + 15;
            text.y = y - 15;
            app.stage.addChild(text);
        });
        
        if (timeSeriesState.points.length === 0) return;
        
        const angles = timeSeriesState.points.map(p => p.angle);
        
        if (timeSeriesState.operationMode === 'average') {
            // Draw circular mean
            const meanAngle = calculateCircularMean(angles);
            const meanX = centerX + Math.cos(meanAngle) * radius;
            const meanY = centerY + Math.sin(meanAngle) * radius;
            
            graphics.lineStyle(8, 0xFFE66D);
            graphics.moveTo(centerX, centerY);
            graphics.lineTo(meanX, meanY);
            
            // Draw mean point
            graphics.beginFill(0xFFE66D);
            graphics.drawCircle(meanX, meanY, 12);
            graphics.endFill();
            
        } else if (timeSeriesState.operationMode === 'derivatives') {
            // Draw derivatives (finite differences)
            const derivatives = calculateDerivatives(angles);
            
            derivatives.forEach((derivative, index) => {
                const derivX = centerX + Math.cos(derivative) * radius * 0.6;
                const derivY = centerY + Math.sin(derivative) * radius * 0.6;
                
                // Use different colors for different derivatives
                const colors = [0xFF6B6B, 0x4ECDC4, 0x45B7D1, 0x96CEB4, 0xFECA57, 0xFF9FF3];
                const color = colors[index % colors.length];
                
                graphics.lineStyle(6, color);
                graphics.moveTo(centerX, centerY);
                graphics.lineTo(derivX, derivY);
                
                // Draw derivative point
                graphics.beginFill(color);
                graphics.drawCircle(derivX, derivY, 8);
                graphics.endFill();
            });
        }
    }
    
    // Event handlers
    app.stage.on('pointerdown', (event) => {
        const pos = event.data.global;
        const centerX = app.screen.width / 2;
        const centerY = app.screen.height / 2;
        
        const angle = Math.atan2(pos.y - centerY, pos.x - centerX);
        
        // Add new point
        timeSeriesState.points.push({ angle: angle });
        draw();
    });
    
    // Hook up dropdown
    const dropdown = document.getElementById('timeseries-operation');
    if (dropdown) {
        dropdown.addEventListener('change', (e) => {
            timeSeriesState.operationMode = e.target.value;
            draw();
        });
    }
    
    // Hook up clear button
    const clearButton = document.getElementById('clear-points');
    if (clearButton) {
        clearButton.addEventListener('click', () => {
            timeSeriesState.points = [];
            // Remove all text objects
            app.stage.children = app.stage.children.filter(child => !(child instanceof PIXI.Text));
            draw();
        });
    }
    
    // Initial draw
    draw();
    
    console.log('Time Series Analyzer initialized');
}


    </script>
</body>
</html>